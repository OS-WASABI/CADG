<div style='display: none'>
@tableofcontents @section README

To view this file in the Firefox web browser, download readmeviewer.html from https://www.genivia.com/files/readmeviewer.html.zip, unzip and copy it to the same directory where this soapReadme.md file is located, then open it in Firefox to view the contents of soapReadme.md.

This markdown file is compatible with Doxygen.
</div>

## Overview {#doc-overview}

This report was generated by soapcpp2 v2.8.75 for interface header file [ipaws.h](ipaws.h) with options -r  -S -L -j -w 

### Tools

The **wsdl2h** command line tool takes a set of WSDL and XSD files to generate a data binding interface header file.  This interface header file is similar to a C/C++ header file and contains declarations of C/C++ types and functions with explanatory comments, directives, and annotations.  Types are declared in this interface header file as serializable.  Functions are declared as Web service operations for the client and server sides.

The **soapcpp2** command line tool takes an interface header file (i.e. a header file) such as [ipaws.h](ipaws.h) to generate the data binding implementation.  This implementation includes XML serializers and source code for the client and server side.  An interface header file for soapcpp2 can be a regular C/C++ header file with type and function declarations (without code), and include annotations to declare XML schema-related properties.

### Files

The following c++ source code files were generated by soapcpp2 for interface header file [ipaws.h](ipaws.h):

- [soapStub.h](soapStub.h) contains an annotated copy of [ipaws.h](ipaws.h) and of the imported files (if any), where most of the information in this report [soapReadme.md](soapReadme.md) is sourced from (this header file also #includes "stdsoap2.h")
- [soapH.h](soapH.h) declares allocation and (de)serialization functions for each C/C++ type, to #include in projects (this header file also #includes "soapStub.h")
- [soapC.cpp](soapC.cpp) defines allocation and (de)serialization functions for each C/C++ type, to compile with a project
- See [Web service class](#doc-server) for the server-side source code files to use

Also compile stdsoap2.cpp (and dom.cpp if XML DOM is used) with a project (or link libgsoapssl++.a) and use the following compile-time options:

- `-DWITH_OPENSSL` to enable HTTPS with OpenSSL
- `-DWITH_GNUTLS` to enable HTTPS with GNUTLS
- `-DWITH_DOM` is required when using the WS-Security plugin
- `-DWITH_GZIP` to enable message compression

See the gSOAP documentation for additional options.

### Contents

This report has the following contents describing the data binding interface types, and the client- and the server-side operations (if any):

- [enumeration types](#doc-enums)
- [class, struct and union types](#doc-classes)
- [typedefs](#doc-typedefs)
- [summary of serializable types](#doc-types)
- [schemas and namespaces](#doc-namespaces)
- [Web service class](#doc-server) lists the methods to implement when developing a service

[![][1] To top](#)


## Enumeration Types {#doc-enums}

<table class="doxtable">
<tr><th> Type </th><th> Declared </th><th> Serializable </th><th> Bitmask </th><th> Values </th></tr>
<tr><td><code><a href="#_ns5__alert_status"> enum _ns5__alert_status </a></code></td><td> ipaws.h:414 </td><td> yes </td><td>  </td><td> <code> _ns5__alert_status__Actual </code>, <code> _ns5__alert_status__Exercise </code>, <code> _ns5__alert_status__System </code>, <code> _ns5__alert_status__Test </code>, <code> _ns5__alert_status__Draft </code> </td></tr>
<tr><td><code><a href="#_ns5__alert_msgType"> enum _ns5__alert_msgType </a></code></td><td> ipaws.h:423 </td><td> yes </td><td>  </td><td> <code> _ns5__alert_msgType__Alert </code>, <code> _ns5__alert_msgType__Update </code>, <code> _ns5__alert_msgType__Cancel </code>, <code> _ns5__alert_msgType__Ack </code>, <code> _ns5__alert_msgType__Error </code> </td></tr>
<tr><td><code><a href="#_ns5__alert_scope"> enum _ns5__alert_scope </a></code></td><td> ipaws.h:434 </td><td> yes </td><td>  </td><td> <code> _ns5__alert_scope__Public </code>, <code> _ns5__alert_scope__Restricted </code>, <code> _ns5__alert_scope__Private </code> </td></tr>
<tr><td><code><a href="#_ns5__alert_info_category"> enum _ns5__alert_info_category </a></code></td><td> ipaws.h:472 </td><td> yes </td><td>  </td><td> <code> _ns5__alert_info_category__Geo </code>, <code> _ns5__alert_info_category__Met </code>, <code> _ns5__alert_info_category__Safety </code>, <code> _ns5__alert_info_category__Security </code>, <code> _ns5__alert_info_category__Rescue </code>, <code> _ns5__alert_info_category__Fire </code>, <code> _ns5__alert_info_category__Health </code>, <code> _ns5__alert_info_category__Env </code>, <code> _ns5__alert_info_category__Transport </code>, <code> _ns5__alert_info_category__Infra </code>, <code> _ns5__alert_info_category__CBRNE </code>, <code> _ns5__alert_info_category__Other </code> </td></tr>
<tr><td><code><a href="#_ns5__alert_info_responseType"> enum _ns5__alert_info_responseType </a></code></td><td> ipaws.h:492 </td><td> yes </td><td>  </td><td> <code> _ns5__alert_info_responseType__Shelter </code>, <code> _ns5__alert_info_responseType__Evacuate </code>, <code> _ns5__alert_info_responseType__Prepare </code>, <code> _ns5__alert_info_responseType__Execute </code>, <code> _ns5__alert_info_responseType__Avoid </code>, <code> _ns5__alert_info_responseType__Monitor </code>, <code> _ns5__alert_info_responseType__Assess </code>, <code> _ns5__alert_info_responseType__AllClear </code>, <code> _ns5__alert_info_responseType__None </code> </td></tr>
<tr><td><code><a href="#_ns5__alert_info_urgency"> enum _ns5__alert_info_urgency </a></code></td><td> ipaws.h:505 </td><td> yes </td><td>  </td><td> <code> _ns5__alert_info_urgency__Immediate </code>, <code> _ns5__alert_info_urgency__Expected </code>, <code> _ns5__alert_info_urgency__Future </code>, <code> _ns5__alert_info_urgency__Past </code>, <code> _ns5__alert_info_urgency__Unknown </code> </td></tr>
<tr><td><code><a href="#_ns5__alert_info_severity"> enum _ns5__alert_info_severity </a></code></td><td> ipaws.h:514 </td><td> yes </td><td>  </td><td> <code> _ns5__alert_info_severity__Extreme </code>, <code> _ns5__alert_info_severity__Severe </code>, <code> _ns5__alert_info_severity__Moderate </code>, <code> _ns5__alert_info_severity__Minor </code>, <code> _ns5__alert_info_severity__Unknown </code> </td></tr>
<tr><td><code><a href="#_ns5__alert_info_certainty"> enum _ns5__alert_info_certainty </a></code></td><td> ipaws.h:523 </td><td> yes </td><td>  </td><td> <code> _ns5__alert_info_certainty__Observed </code>, <code> _ns5__alert_info_certainty__Likely </code>, <code> _ns5__alert_info_certainty__Possible </code>, <code> _ns5__alert_info_certainty__Unlikely </code>, <code> _ns5__alert_info_certainty__Unknown </code> </td></tr>
</table>

<a name="_ns5__alert_status"></a>

### `enum _ns5__alert_status`

This enum type is declared in [ipaws.h](ipaws.h) at line 414 and has values  `_ns5__alert_status__Actual` (= 0), `_ns5__alert_status__Exercise` (= 1), `_ns5__alert_status__System` (= 2), `_ns5__alert_status__Test` (= 3), `_ns5__alert_status__Draft` (= 4).

- `enum _ns5__alert_status *soap_new__ns5__alert_status(struct soap*)` managed allocation with default initialization
- `enum _ns5__alert_status *soap_new__ns5__alert_status(struct soap*, int n)` managed allocation with default initialization of array `enum _ns5__alert_status[n]`
- `void soap_default__ns5__alert_status(struct soap*, enum _ns5__alert_status *value)` set to default value
- `const char *soap__ns5__alert_status2s(struct soap*, enum _ns5__alert_status value)` returns string-converted value in temporary string buffer
- `int soap_s2_ns5__alert_status(struct soap*, const char*, enum _ns5__alert_status *value)` convert string to value, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns5__alert_msgType"></a>

### `enum _ns5__alert_msgType`

This enum type is declared in [ipaws.h](ipaws.h) at line 423 and has values  `_ns5__alert_msgType__Alert` (= 0), `_ns5__alert_msgType__Update` (= 1), `_ns5__alert_msgType__Cancel` (= 2), `_ns5__alert_msgType__Ack` (= 3), `_ns5__alert_msgType__Error` (= 4).

- `enum _ns5__alert_msgType *soap_new__ns5__alert_msgType(struct soap*)` managed allocation with default initialization
- `enum _ns5__alert_msgType *soap_new__ns5__alert_msgType(struct soap*, int n)` managed allocation with default initialization of array `enum _ns5__alert_msgType[n]`
- `void soap_default__ns5__alert_msgType(struct soap*, enum _ns5__alert_msgType *value)` set to default value
- `const char *soap__ns5__alert_msgType2s(struct soap*, enum _ns5__alert_msgType value)` returns string-converted value in temporary string buffer
- `int soap_s2_ns5__alert_msgType(struct soap*, const char*, enum _ns5__alert_msgType *value)` convert string to value, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns5__alert_scope"></a>

### `enum _ns5__alert_scope`

This enum type is declared in [ipaws.h](ipaws.h) at line 434 and has values  `_ns5__alert_scope__Public` (= 0), `_ns5__alert_scope__Restricted` (= 1), `_ns5__alert_scope__Private` (= 2).

- `enum _ns5__alert_scope *soap_new__ns5__alert_scope(struct soap*)` managed allocation with default initialization
- `enum _ns5__alert_scope *soap_new__ns5__alert_scope(struct soap*, int n)` managed allocation with default initialization of array `enum _ns5__alert_scope[n]`
- `void soap_default__ns5__alert_scope(struct soap*, enum _ns5__alert_scope *value)` set to default value
- `const char *soap__ns5__alert_scope2s(struct soap*, enum _ns5__alert_scope value)` returns string-converted value in temporary string buffer
- `int soap_s2_ns5__alert_scope(struct soap*, const char*, enum _ns5__alert_scope *value)` convert string to value, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns5__alert_info_category"></a>

### `enum _ns5__alert_info_category`

This enum type is declared in [ipaws.h](ipaws.h) at line 472 and has values  `_ns5__alert_info_category__Geo` (= 0), `_ns5__alert_info_category__Met` (= 1), `_ns5__alert_info_category__Safety` (= 2), `_ns5__alert_info_category__Security` (= 3), `_ns5__alert_info_category__Rescue` (= 4), `_ns5__alert_info_category__Fire` (= 5), `_ns5__alert_info_category__Health` (= 6), `_ns5__alert_info_category__Env` (= 7), `_ns5__alert_info_category__Transport` (= 8), `_ns5__alert_info_category__Infra` (= 9), `_ns5__alert_info_category__CBRNE` (= 10), `_ns5__alert_info_category__Other` (= 11).

- `enum _ns5__alert_info_category *soap_new__ns5__alert_info_category(struct soap*)` managed allocation with default initialization
- `enum _ns5__alert_info_category *soap_new__ns5__alert_info_category(struct soap*, int n)` managed allocation with default initialization of array `enum _ns5__alert_info_category[n]`
- `void soap_default__ns5__alert_info_category(struct soap*, enum _ns5__alert_info_category *value)` set to default value
- `const char *soap__ns5__alert_info_category2s(struct soap*, enum _ns5__alert_info_category value)` returns string-converted value in temporary string buffer
- `int soap_s2_ns5__alert_info_category(struct soap*, const char*, enum _ns5__alert_info_category *value)` convert string to value, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns5__alert_info_responseType"></a>

### `enum _ns5__alert_info_responseType`

This enum type is declared in [ipaws.h](ipaws.h) at line 492 and has values  `_ns5__alert_info_responseType__Shelter` (= 0), `_ns5__alert_info_responseType__Evacuate` (= 1), `_ns5__alert_info_responseType__Prepare` (= 2), `_ns5__alert_info_responseType__Execute` (= 3), `_ns5__alert_info_responseType__Avoid` (= 4), `_ns5__alert_info_responseType__Monitor` (= 5), `_ns5__alert_info_responseType__Assess` (= 6), `_ns5__alert_info_responseType__AllClear` (= 7), `_ns5__alert_info_responseType__None` (= 8).

- `enum _ns5__alert_info_responseType *soap_new__ns5__alert_info_responseType(struct soap*)` managed allocation with default initialization
- `enum _ns5__alert_info_responseType *soap_new__ns5__alert_info_responseType(struct soap*, int n)` managed allocation with default initialization of array `enum _ns5__alert_info_responseType[n]`
- `void soap_default__ns5__alert_info_responseType(struct soap*, enum _ns5__alert_info_responseType *value)` set to default value
- `const char *soap__ns5__alert_info_responseType2s(struct soap*, enum _ns5__alert_info_responseType value)` returns string-converted value in temporary string buffer
- `int soap_s2_ns5__alert_info_responseType(struct soap*, const char*, enum _ns5__alert_info_responseType *value)` convert string to value, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns5__alert_info_urgency"></a>

### `enum _ns5__alert_info_urgency`

This enum type is declared in [ipaws.h](ipaws.h) at line 505 and has values  `_ns5__alert_info_urgency__Immediate` (= 0), `_ns5__alert_info_urgency__Expected` (= 1), `_ns5__alert_info_urgency__Future` (= 2), `_ns5__alert_info_urgency__Past` (= 3), `_ns5__alert_info_urgency__Unknown` (= 4).

- `enum _ns5__alert_info_urgency *soap_new__ns5__alert_info_urgency(struct soap*)` managed allocation with default initialization
- `enum _ns5__alert_info_urgency *soap_new__ns5__alert_info_urgency(struct soap*, int n)` managed allocation with default initialization of array `enum _ns5__alert_info_urgency[n]`
- `void soap_default__ns5__alert_info_urgency(struct soap*, enum _ns5__alert_info_urgency *value)` set to default value
- `const char *soap__ns5__alert_info_urgency2s(struct soap*, enum _ns5__alert_info_urgency value)` returns string-converted value in temporary string buffer
- `int soap_s2_ns5__alert_info_urgency(struct soap*, const char*, enum _ns5__alert_info_urgency *value)` convert string to value, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns5__alert_info_severity"></a>

### `enum _ns5__alert_info_severity`

This enum type is declared in [ipaws.h](ipaws.h) at line 514 and has values  `_ns5__alert_info_severity__Extreme` (= 0), `_ns5__alert_info_severity__Severe` (= 1), `_ns5__alert_info_severity__Moderate` (= 2), `_ns5__alert_info_severity__Minor` (= 3), `_ns5__alert_info_severity__Unknown` (= 4).

- `enum _ns5__alert_info_severity *soap_new__ns5__alert_info_severity(struct soap*)` managed allocation with default initialization
- `enum _ns5__alert_info_severity *soap_new__ns5__alert_info_severity(struct soap*, int n)` managed allocation with default initialization of array `enum _ns5__alert_info_severity[n]`
- `void soap_default__ns5__alert_info_severity(struct soap*, enum _ns5__alert_info_severity *value)` set to default value
- `const char *soap__ns5__alert_info_severity2s(struct soap*, enum _ns5__alert_info_severity value)` returns string-converted value in temporary string buffer
- `int soap_s2_ns5__alert_info_severity(struct soap*, const char*, enum _ns5__alert_info_severity *value)` convert string to value, returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns5__alert_info_certainty"></a>

### `enum _ns5__alert_info_certainty`

This enum type is declared in [ipaws.h](ipaws.h) at line 523 and has values  `_ns5__alert_info_certainty__Observed` (= 0), `_ns5__alert_info_certainty__Likely` (= 1), `_ns5__alert_info_certainty__Possible` (= 2), `_ns5__alert_info_certainty__Unlikely` (= 3), `_ns5__alert_info_certainty__Unknown` (= 4).

- `enum _ns5__alert_info_certainty *soap_new__ns5__alert_info_certainty(struct soap*)` managed allocation with default initialization
- `enum _ns5__alert_info_certainty *soap_new__ns5__alert_info_certainty(struct soap*, int n)` managed allocation with default initialization of array `enum _ns5__alert_info_certainty[n]`
- `void soap_default__ns5__alert_info_certainty(struct soap*, enum _ns5__alert_info_certainty *value)` set to default value
- `const char *soap__ns5__alert_info_certainty2s(struct soap*, enum _ns5__alert_info_certainty value)` returns string-converted value in temporary string buffer
- `int soap_s2_ns5__alert_info_certainty(struct soap*, const char*, enum _ns5__alert_info_certainty *value)` convert string to value, returns `SOAP_OK` or error code

[![][1] To top](#)


## Class, Struct and Union Types {#doc-classes}

The table below lists the classes, structs and unions declared in [ipaws.h](ipaws.h) or that are imported:

<table class="doxtable">
<tr><th> Type </th><th> Declared </th><th> Serializable </th></tr>
<tr><td><code><a href="#ns3__requestParameterList"> ns3__requestParameterList </a></code></td><td> ipaws.h:182 </td><td> yes </td></tr>
<tr><td><code><a href="#ns3__parameterListItem"> ns3__parameterListItem </a></code></td><td> ipaws.h:184 </td><td> yes </td></tr>
<tr><td><code><a href="#ns4__responseParameterList"> ns4__responseParameterList </a></code></td><td> ipaws.h:186 </td><td> yes </td></tr>
<tr><td><code><a href="#ns4__subParameterListItem"> ns4__subParameterListItem </a></code></td><td> ipaws.h:188 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns4__parameterListItem"> _ns4__parameterListItem </a></code></td><td> ipaws.h:190 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns5__alert_info_eventCode"> _ns5__alert_info_eventCode </a></code></td><td> ipaws.h:546 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns5__alert_info_parameter"> _ns5__alert_info_parameter </a></code></td><td> ipaws.h:587 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns5__alert_info_resource"> _ns5__alert_info_resource </a></code></td><td> ipaws.h:607 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns5__alert_info_area_geocode"> _ns5__alert_info_area_geocode </a></code></td><td> ipaws.h:656 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns5__alert_info_area"> _ns5__alert_info_area </a></code></td><td> ipaws.h:635 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns5__alert_info"> _ns5__alert_info </a></code></td><td> ipaws.h:465 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns5__alert"> _ns5__alert </a></code></td><td> ipaws.h:192 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns2__postCAPRequestTypeDef"> _ns2__postCAPRequestTypeDef </a></code></td><td> ipaws.h:194 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns2__CAPServiceException"> _ns2__CAPServiceException </a></code></td><td> ipaws.h:196 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns2__postCAPResponseTypeDef"> _ns2__postCAPResponseTypeDef </a></code></td><td> ipaws.h:198 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns2__messageResponseTypeDef"> _ns2__messageResponseTypeDef </a></code></td><td> ipaws.h:200 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns2__CAPHeaderTypeDef"> _ns2__CAPHeaderTypeDef </a></code></td><td> ipaws.h:202 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Header"> struct SOAP_ENV__Header </a></code></td><td> ipaws.h:960 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Detail"> struct SOAP_ENV__Detail </a></code></td><td> ipaws.h:983 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns2__getRequest"> struct __ns2__getRequest </a></code></td><td> ipaws.h:1076 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns2__postCAP"> struct __ns2__postCAP </a></code></td><td> ipaws.h:1153 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns2__getMessage"> struct __ns2__getMessage </a></code></td><td> ipaws.h:1230 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Code"> struct SOAP_ENV__Code </a></code></td><td> ipaws.h:1412 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Reason"> struct SOAP_ENV__Reason </a></code></td><td> ipaws.h:1412 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Fault"> struct SOAP_ENV__Fault </a></code></td><td> ipaws.h:1412 </td><td> yes </td></tr>
</table>

<a name="ns3__requestParameterList"></a>

### `ns3__requestParameterList`

This class is declared in [ipaws.h](ipaws.h) at line 182, is serialized as XML schema type *`ns3:requestParameterList`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns3__requestParameterList {
      public:
        /// Optional element 'ns3:requestAPI' of XML schema type 'xsd:string'
        std::string *requestAPI;
        /// Optional element 'ns3:requestOperation' of XML schema type 'xsd:string'
        std::string *requestOperation;
        /// Optional element 'ns3:parameters' of XML schema type 'ns3:parameterListItem'
        std::vector<ns3__parameterListItem *> parameters;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__requestParameterList
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__requestParameterList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__requestParameterList, default initialized and not managed by a soap context
        virtual ns3__requestParameterList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__requestParameterList); }
      public:
        /// Constructor with default initializations
        ns3__requestParameterList() : requestAPI(), requestOperation(), parameters(), soap() { }
        virtual ~ns3__requestParameterList() { }
        /// Friend allocator used by soap_new_ns3__requestParameterList(struct soap*, int)
        friend SOAP_FMAC1 ns3__requestParameterList * SOAP_FMAC2 soap_instantiate_ns3__requestParameterList(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *requestAPI` is an optional element *`<ns3:requestAPI>`* of XML schema type *`xsd:string`*
- `std::string *requestOperation` is an optional element *`<ns3:requestOperation>`* of XML schema type *`xsd:string`*
- `std::vector<ns3__parameterListItem *> parameters` is an optional element *`<ns3:parameters>`* of XML schema type *`ns3:parameterListItem`*, where the type of this member is a container of pointers to <code><a href="#ns3__parameterListItem"> ns3__parameterListItem </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `ns3__requestParameterList` are available:

- `ns3__requestParameterList *soap_new_ns3__requestParameterList(struct soap*)` managed allocation with default initialization
- `ns3__requestParameterList *soap_new_ns3__requestParameterList(struct soap*, int n)` managed allocation of array `ns3__requestParameterList[n]`
- `ns3__requestParameterList *soap_new_req_ns3__requestParameterList(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns3__requestParameterList *soap_new_set_ns3__requestParameterList(struct soap*, std::string *requestAPI, std::string *requestOperation, const std::vector<ns3__parameterListItem *> & parameters)` managed allocation with public members assigned the values of these parameters
- `void ns3__requestParameterList::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns3__requestParameterList(struct soap*, const ns3__requestParameterList*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns3__requestParameterList(struct soap*, const char *URL, const ns3__requestParameterList*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns3__requestParameterList(struct soap*, const char *URL, const ns3__requestParameterList*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns3__requestParameterList(struct soap*, const char *URL, const ns3__requestParameterList*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns3__requestParameterList(struct soap*, ns3__requestParameterList*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns3__requestParameterList(struct soap*, const char *URL, ns3__requestParameterList*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns3__requestParameterList(struct soap*, ns3__requestParameterList*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns3__parameterListItem"></a>

### `ns3__parameterListItem`

This class is declared in [ipaws.h](ipaws.h) at line 184, is serialized as XML schema type *`ns3:parameterListItem`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns3__parameterListItem {
      public:
        /// Optional element 'ns3:parameterName' of XML schema type 'xsd:string'
        std::string *parameterName;
        /// Optional element 'ns3:comparisonOp' of XML schema type 'xsd:string'
        std::string *comparisonOp;
        /// Optional element 'ns3:parameterValue' of XML schema type 'xsd:string'
        std::vector<std::string> parameterValue;
        /// Optional element 'ns3:logicalOp' of XML schema type 'xsd:string'
        std::string *logicalOp;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns3__parameterListItem
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__parameterListItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__parameterListItem, default initialized and not managed by a soap context
        virtual ns3__parameterListItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__parameterListItem); }
      public:
        /// Constructor with default initializations
        ns3__parameterListItem() : parameterName(), comparisonOp(), parameterValue(), logicalOp(), soap() { }
        virtual ~ns3__parameterListItem() { }
        /// Friend allocator used by soap_new_ns3__parameterListItem(struct soap*, int)
        friend SOAP_FMAC1 ns3__parameterListItem * SOAP_FMAC2 soap_instantiate_ns3__parameterListItem(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *parameterName` is an optional element *`<ns3:parameterName>`* of XML schema type *`xsd:string`*
- `std::string *comparisonOp` is an optional element *`<ns3:comparisonOp>`* of XML schema type *`xsd:string`*
- `std::vector<std::string> parameterValue` is an optional element *`<ns3:parameterValue>`* of XML schema type *`xsd:string`*
- `std::string *logicalOp` is an optional element *`<ns3:logicalOp>`* of XML schema type *`xsd:string`*
- `struct soap *soap` the context that manages this object

The following operations on `ns3__parameterListItem` are available:

- `ns3__parameterListItem *soap_new_ns3__parameterListItem(struct soap*)` managed allocation with default initialization
- `ns3__parameterListItem *soap_new_ns3__parameterListItem(struct soap*, int n)` managed allocation of array `ns3__parameterListItem[n]`
- `ns3__parameterListItem *soap_new_req_ns3__parameterListItem(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns3__parameterListItem *soap_new_set_ns3__parameterListItem(struct soap*, std::string *parameterName, std::string *comparisonOp, const std::vector<std::string> & parameterValue, std::string *logicalOp)` managed allocation with public members assigned the values of these parameters
- `void ns3__parameterListItem::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns3__parameterListItem(struct soap*, const ns3__parameterListItem*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns3__parameterListItem(struct soap*, const char *URL, const ns3__parameterListItem*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns3__parameterListItem(struct soap*, const char *URL, const ns3__parameterListItem*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns3__parameterListItem(struct soap*, const char *URL, const ns3__parameterListItem*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns3__parameterListItem(struct soap*, ns3__parameterListItem*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns3__parameterListItem(struct soap*, const char *URL, ns3__parameterListItem*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns3__parameterListItem(struct soap*, ns3__parameterListItem*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns4__responseParameterList"></a>

### `ns4__responseParameterList`

This class is declared in [ipaws.h](ipaws.h) at line 186, is serialized as XML schema type *`ns4:responseParameterList`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns4__responseParameterList {
      public:
        /// Optional element 'ns4:parameterListItem' of XML schema type 'ns4:parameterListItem'
        std::vector<_ns4__parameterListItem *> parameterListItem;
        /// Optional element 'ns4:ResponseOperation' of XML schema type 'xsd:string'
        std::string *ResponseOperation;
        /// Optional element 'ns4:ResponseType' of XML schema type 'xsd:string'
        std::string *ResponseType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__responseParameterList
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__responseParameterList; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__responseParameterList, default initialized and not managed by a soap context
        virtual ns4__responseParameterList *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns4__responseParameterList); }
      public:
        /// Constructor with default initializations
        ns4__responseParameterList() : parameterListItem(), ResponseOperation(), ResponseType(), soap() { }
        virtual ~ns4__responseParameterList() { }
        /// Friend allocator used by soap_new_ns4__responseParameterList(struct soap*, int)
        friend SOAP_FMAC1 ns4__responseParameterList * SOAP_FMAC2 soap_instantiate_ns4__responseParameterList(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::vector<_ns4__parameterListItem *> parameterListItem` is an optional element *`<ns4:parameterListItem>`* of XML schema type *`ns4:parameterListItem`*, where the type of this member is a container of pointers to <code><a href="#_ns4__parameterListItem"> _ns4__parameterListItem </a></code>
- `std::string *ResponseOperation` is an optional element *`<ns4:ResponseOperation>`* of XML schema type *`xsd:string`*
- `std::string *ResponseType` is an optional element *`<ns4:ResponseType>`* of XML schema type *`xsd:string`*
- `struct soap *soap` the context that manages this object

The following operations on `ns4__responseParameterList` are available:

- `ns4__responseParameterList *soap_new_ns4__responseParameterList(struct soap*)` managed allocation with default initialization
- `ns4__responseParameterList *soap_new_ns4__responseParameterList(struct soap*, int n)` managed allocation of array `ns4__responseParameterList[n]`
- `ns4__responseParameterList *soap_new_req_ns4__responseParameterList(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns4__responseParameterList *soap_new_set_ns4__responseParameterList(struct soap*, const std::vector<_ns4__parameterListItem *> & parameterListItem, std::string *ResponseOperation, std::string *ResponseType)` managed allocation with public members assigned the values of these parameters
- `void ns4__responseParameterList::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns4__responseParameterList(struct soap*, const ns4__responseParameterList*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns4__responseParameterList(struct soap*, const char *URL, const ns4__responseParameterList*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns4__responseParameterList(struct soap*, const char *URL, const ns4__responseParameterList*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns4__responseParameterList(struct soap*, const char *URL, const ns4__responseParameterList*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns4__responseParameterList(struct soap*, ns4__responseParameterList*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns4__responseParameterList(struct soap*, const char *URL, ns4__responseParameterList*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns4__responseParameterList(struct soap*, ns4__responseParameterList*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns4__subParameterListItem"></a>

### `ns4__subParameterListItem`

This class is declared in [ipaws.h](ipaws.h) at line 188, is serialized as XML schema type *`ns4:subParameterListItem`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns4__subParameterListItem {
      public:
        /// Optional element 'ns4:subParameterName' of XML schema type 'xsd:string'
        std::string *subParameterName;
        /// Optional element 'ns4:subParameterValue' of XML schema type 'xsd:string'
        std::string *subParameterValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns4__subParameterListItem
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__subParameterListItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__subParameterListItem, default initialized and not managed by a soap context
        virtual ns4__subParameterListItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns4__subParameterListItem); }
      public:
        /// Constructor with default initializations
        ns4__subParameterListItem() : subParameterName(), subParameterValue(), soap() { }
        virtual ~ns4__subParameterListItem() { }
        /// Friend allocator used by soap_new_ns4__subParameterListItem(struct soap*, int)
        friend SOAP_FMAC1 ns4__subParameterListItem * SOAP_FMAC2 soap_instantiate_ns4__subParameterListItem(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *subParameterName` is an optional element *`<ns4:subParameterName>`* of XML schema type *`xsd:string`*
- `std::string *subParameterValue` is an optional element *`<ns4:subParameterValue>`* of XML schema type *`xsd:string`*
- `struct soap *soap` the context that manages this object

The following operations on `ns4__subParameterListItem` are available:

- `ns4__subParameterListItem *soap_new_ns4__subParameterListItem(struct soap*)` managed allocation with default initialization
- `ns4__subParameterListItem *soap_new_ns4__subParameterListItem(struct soap*, int n)` managed allocation of array `ns4__subParameterListItem[n]`
- `ns4__subParameterListItem *soap_new_req_ns4__subParameterListItem(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns4__subParameterListItem *soap_new_set_ns4__subParameterListItem(struct soap*, std::string *subParameterName, std::string *subParameterValue)` managed allocation with public members assigned the values of these parameters
- `void ns4__subParameterListItem::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns4__subParameterListItem(struct soap*, const ns4__subParameterListItem*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns4__subParameterListItem(struct soap*, const char *URL, const ns4__subParameterListItem*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns4__subParameterListItem(struct soap*, const char *URL, const ns4__subParameterListItem*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns4__subParameterListItem(struct soap*, const char *URL, const ns4__subParameterListItem*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns4__subParameterListItem(struct soap*, ns4__subParameterListItem*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns4__subParameterListItem(struct soap*, const char *URL, ns4__subParameterListItem*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns4__subParameterListItem(struct soap*, ns4__subParameterListItem*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns4__parameterListItem"></a>

### `_ns4__parameterListItem`

This class is declared in [ipaws.h](ipaws.h) at line 190, is serialized as XML schema type *`ns4:parameterListItem`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns4__parameterListItem {
      public:
        /// Optional element 'ns4:parameterName' of XML schema type 'xsd:string'
        std::string *parameterName;
        /// Optional element 'ns4:parameterValue' of XML schema type 'xsd:string'
        std::string *parameterValue;
        /// Optional element 'ns4:subParaListItem' of XML schema type 'ns4:subParameterListItem'
        std::vector<ns4__subParameterListItem *> subParaListItem;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns4__parameterListItem
        virtual long soap_type(void) const { return SOAP_TYPE__ns4__parameterListItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns4__parameterListItem, default initialized and not managed by a soap context
        virtual _ns4__parameterListItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns4__parameterListItem); }
      public:
        /// Constructor with default initializations
        _ns4__parameterListItem() : parameterName(), parameterValue(), subParaListItem(), soap() { }
        virtual ~_ns4__parameterListItem() { }
        /// Friend allocator used by soap_new__ns4__parameterListItem(struct soap*, int)
        friend SOAP_FMAC1 _ns4__parameterListItem * SOAP_FMAC2 soap_instantiate__ns4__parameterListItem(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *parameterName` is an optional element *`<ns4:parameterName>`* of XML schema type *`xsd:string`*
- `std::string *parameterValue` is an optional element *`<ns4:parameterValue>`* of XML schema type *`xsd:string`*
- `std::vector<ns4__subParameterListItem *> subParaListItem` is an optional element *`<ns4:subParaListItem>`* of XML schema type *`ns4:subParameterListItem`*, where the type of this member is a container of pointers to <code><a href="#ns4__subParameterListItem"> ns4__subParameterListItem </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `_ns4__parameterListItem` are available:

- `_ns4__parameterListItem *soap_new__ns4__parameterListItem(struct soap*)` managed allocation with default initialization
- `_ns4__parameterListItem *soap_new__ns4__parameterListItem(struct soap*, int n)` managed allocation of array `_ns4__parameterListItem[n]`
- `_ns4__parameterListItem *soap_new_req__ns4__parameterListItem(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns4__parameterListItem *soap_new_set__ns4__parameterListItem(struct soap*, std::string *parameterName, std::string *parameterValue, const std::vector<ns4__subParameterListItem *> & subParaListItem)` managed allocation with public members assigned the values of these parameters
- `void _ns4__parameterListItem::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns4__parameterListItem(struct soap*, const _ns4__parameterListItem*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns4__parameterListItem(struct soap*, const char *URL, const _ns4__parameterListItem*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns4__parameterListItem(struct soap*, const char *URL, const _ns4__parameterListItem*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns4__parameterListItem(struct soap*, const char *URL, const _ns4__parameterListItem*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns4__parameterListItem(struct soap*, _ns4__parameterListItem*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns4__parameterListItem(struct soap*, const char *URL, _ns4__parameterListItem*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns4__parameterListItem(struct soap*, _ns4__parameterListItem*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns5__alert_info_eventCode"></a>

### `_ns5__alert_info_eventCode`

This class is declared in [ipaws.h](ipaws.h) at line 546, is serialized as XML schema type *`ns5:alert-info-eventCode`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns5__alert_info_eventCode {
      public:
        /// Required element 'ns5:valueName' of XML schema type 'xsd:string'
        std::string valueName;
        /// Required element 'ns5:value' of XML schema type 'xsd:string'
        std::string value;
      public:
        /// Return unique type id SOAP_TYPE__ns5__alert_info_eventCode
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__alert_info_eventCode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__alert_info_eventCode, default initialized and not managed by a soap context
        virtual _ns5__alert_info_eventCode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns5__alert_info_eventCode); }
      public:
        /// Constructor with default initializations
        _ns5__alert_info_eventCode() : valueName(), value() { }
        virtual ~_ns5__alert_info_eventCode() { }
        /// Friend allocator used by soap_new__ns5__alert_info_eventCode(struct soap*, int)
        friend SOAP_FMAC1 _ns5__alert_info_eventCode * SOAP_FMAC2 soap_instantiate__ns5__alert_info_eventCode(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string valueName` is a required element *`<ns5:valueName>`* of XML schema type *`xsd:string`*
- `std::string value` is a required element *`<ns5:value>`* of XML schema type *`xsd:string`*

The following operations on `_ns5__alert_info_eventCode` are available:

- `_ns5__alert_info_eventCode *soap_new__ns5__alert_info_eventCode(struct soap*)` managed allocation with default initialization
- `_ns5__alert_info_eventCode *soap_new__ns5__alert_info_eventCode(struct soap*, int n)` managed allocation of array `_ns5__alert_info_eventCode[n]`
- `_ns5__alert_info_eventCode *soap_new_req__ns5__alert_info_eventCode(struct soap*, const std::string& valueName, const std::string& value)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns5__alert_info_eventCode *soap_new_set__ns5__alert_info_eventCode(struct soap*, const std::string& valueName, const std::string& value)` managed allocation with public members assigned the values of these parameters
- `void _ns5__alert_info_eventCode::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns5__alert_info_eventCode(struct soap*, const _ns5__alert_info_eventCode*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns5__alert_info_eventCode(struct soap*, const char *URL, const _ns5__alert_info_eventCode*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns5__alert_info_eventCode(struct soap*, const char *URL, const _ns5__alert_info_eventCode*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns5__alert_info_eventCode(struct soap*, const char *URL, const _ns5__alert_info_eventCode*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns5__alert_info_eventCode(struct soap*, _ns5__alert_info_eventCode*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns5__alert_info_eventCode(struct soap*, const char *URL, _ns5__alert_info_eventCode*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns5__alert_info_eventCode(struct soap*, _ns5__alert_info_eventCode*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns5__alert_info_parameter"></a>

### `_ns5__alert_info_parameter`

This class is declared in [ipaws.h](ipaws.h) at line 587, is serialized as XML schema type *`ns5:alert-info-parameter`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns5__alert_info_parameter {
      public:
        /// Required element 'ns5:valueName' of XML schema type 'xsd:string'
        std::string valueName;
        /// Required element 'ns5:value' of XML schema type 'xsd:string'
        std::string value;
      public:
        /// Return unique type id SOAP_TYPE__ns5__alert_info_parameter
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__alert_info_parameter; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__alert_info_parameter, default initialized and not managed by a soap context
        virtual _ns5__alert_info_parameter *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns5__alert_info_parameter); }
      public:
        /// Constructor with default initializations
        _ns5__alert_info_parameter() : valueName(), value() { }
        virtual ~_ns5__alert_info_parameter() { }
        /// Friend allocator used by soap_new__ns5__alert_info_parameter(struct soap*, int)
        friend SOAP_FMAC1 _ns5__alert_info_parameter * SOAP_FMAC2 soap_instantiate__ns5__alert_info_parameter(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string valueName` is a required element *`<ns5:valueName>`* of XML schema type *`xsd:string`*
- `std::string value` is a required element *`<ns5:value>`* of XML schema type *`xsd:string`*

The following operations on `_ns5__alert_info_parameter` are available:

- `_ns5__alert_info_parameter *soap_new__ns5__alert_info_parameter(struct soap*)` managed allocation with default initialization
- `_ns5__alert_info_parameter *soap_new__ns5__alert_info_parameter(struct soap*, int n)` managed allocation of array `_ns5__alert_info_parameter[n]`
- `_ns5__alert_info_parameter *soap_new_req__ns5__alert_info_parameter(struct soap*, const std::string& valueName, const std::string& value)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns5__alert_info_parameter *soap_new_set__ns5__alert_info_parameter(struct soap*, const std::string& valueName, const std::string& value)` managed allocation with public members assigned the values of these parameters
- `void _ns5__alert_info_parameter::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns5__alert_info_parameter(struct soap*, const _ns5__alert_info_parameter*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns5__alert_info_parameter(struct soap*, const char *URL, const _ns5__alert_info_parameter*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns5__alert_info_parameter(struct soap*, const char *URL, const _ns5__alert_info_parameter*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns5__alert_info_parameter(struct soap*, const char *URL, const _ns5__alert_info_parameter*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns5__alert_info_parameter(struct soap*, _ns5__alert_info_parameter*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns5__alert_info_parameter(struct soap*, const char *URL, _ns5__alert_info_parameter*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns5__alert_info_parameter(struct soap*, _ns5__alert_info_parameter*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns5__alert_info_resource"></a>

### `_ns5__alert_info_resource`

This class is declared in [ipaws.h](ipaws.h) at line 607, is serialized as XML schema type *`ns5:alert-info-resource`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns5__alert_info_resource {
      public:
        /// Required element 'ns5:resourceDesc' of XML schema type 'xsd:string'
        std::string resourceDesc;
        /// Required element 'ns5:mimeType' of XML schema type 'xsd:string'
        std::string mimeType;
        /// Optional element 'ns5:size' of XML schema type 'xsd:integer'
        std::string *size;
        /// Optional element 'ns5:uri' of XML schema type 'xsd:anyURI'
        std::string *uri;
        /// Optional element 'ns5:derefUri' of XML schema type 'xsd:string'
        std::string *derefUri;
        /// Optional element 'ns5:digest' of XML schema type 'xsd:string'
        std::string *digest;
      public:
        /// Return unique type id SOAP_TYPE__ns5__alert_info_resource
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__alert_info_resource; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__alert_info_resource, default initialized and not managed by a soap context
        virtual _ns5__alert_info_resource *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns5__alert_info_resource); }
      public:
        /// Constructor with default initializations
        _ns5__alert_info_resource() : resourceDesc(), mimeType(), size(), uri(), derefUri(), digest() { }
        virtual ~_ns5__alert_info_resource() { }
        /// Friend allocator used by soap_new__ns5__alert_info_resource(struct soap*, int)
        friend SOAP_FMAC1 _ns5__alert_info_resource * SOAP_FMAC2 soap_instantiate__ns5__alert_info_resource(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string resourceDesc` is a required element *`<ns5:resourceDesc>`* of XML schema type *`xsd:string`*
- `std::string mimeType` is a required element *`<ns5:mimeType>`* of XML schema type *`xsd:string`*
- `std::string *size` is an optional element *`<ns5:size>`* of XML schema type *`xsd:integer`*
- `std::string *uri` is an optional element *`<ns5:uri>`* of XML schema type *`xsd:anyURI`*
- `std::string *derefUri` is an optional element *`<ns5:derefUri>`* of XML schema type *`xsd:string`*
- `std::string *digest` is an optional element *`<ns5:digest>`* of XML schema type *`xsd:string`*

The following operations on `_ns5__alert_info_resource` are available:

- `_ns5__alert_info_resource *soap_new__ns5__alert_info_resource(struct soap*)` managed allocation with default initialization
- `_ns5__alert_info_resource *soap_new__ns5__alert_info_resource(struct soap*, int n)` managed allocation of array `_ns5__alert_info_resource[n]`
- `_ns5__alert_info_resource *soap_new_req__ns5__alert_info_resource(struct soap*, const std::string& resourceDesc, const std::string& mimeType)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns5__alert_info_resource *soap_new_set__ns5__alert_info_resource(struct soap*, const std::string& resourceDesc, const std::string& mimeType, std::string *size, std::string *uri, std::string *derefUri, std::string *digest)` managed allocation with public members assigned the values of these parameters
- `void _ns5__alert_info_resource::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns5__alert_info_resource(struct soap*, const _ns5__alert_info_resource*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns5__alert_info_resource(struct soap*, const char *URL, const _ns5__alert_info_resource*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns5__alert_info_resource(struct soap*, const char *URL, const _ns5__alert_info_resource*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns5__alert_info_resource(struct soap*, const char *URL, const _ns5__alert_info_resource*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns5__alert_info_resource(struct soap*, _ns5__alert_info_resource*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns5__alert_info_resource(struct soap*, const char *URL, _ns5__alert_info_resource*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns5__alert_info_resource(struct soap*, _ns5__alert_info_resource*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns5__alert_info_area_geocode"></a>

### `_ns5__alert_info_area_geocode`

This class is declared in [ipaws.h](ipaws.h) at line 656, is serialized as XML schema type *`ns5:alert-info-area-geocode`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns5__alert_info_area_geocode {
      public:
        /// Required element 'ns5:valueName' of XML schema type 'xsd:string'
        std::string valueName;
        /// Required element 'ns5:value' of XML schema type 'xsd:string'
        std::string value;
      public:
        /// Return unique type id SOAP_TYPE__ns5__alert_info_area_geocode
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__alert_info_area_geocode; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__alert_info_area_geocode, default initialized and not managed by a soap context
        virtual _ns5__alert_info_area_geocode *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns5__alert_info_area_geocode); }
      public:
        /// Constructor with default initializations
        _ns5__alert_info_area_geocode() : valueName(), value() { }
        virtual ~_ns5__alert_info_area_geocode() { }
        /// Friend allocator used by soap_new__ns5__alert_info_area_geocode(struct soap*, int)
        friend SOAP_FMAC1 _ns5__alert_info_area_geocode * SOAP_FMAC2 soap_instantiate__ns5__alert_info_area_geocode(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string valueName` is a required element *`<ns5:valueName>`* of XML schema type *`xsd:string`*
- `std::string value` is a required element *`<ns5:value>`* of XML schema type *`xsd:string`*

The following operations on `_ns5__alert_info_area_geocode` are available:

- `_ns5__alert_info_area_geocode *soap_new__ns5__alert_info_area_geocode(struct soap*)` managed allocation with default initialization
- `_ns5__alert_info_area_geocode *soap_new__ns5__alert_info_area_geocode(struct soap*, int n)` managed allocation of array `_ns5__alert_info_area_geocode[n]`
- `_ns5__alert_info_area_geocode *soap_new_req__ns5__alert_info_area_geocode(struct soap*, const std::string& valueName, const std::string& value)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns5__alert_info_area_geocode *soap_new_set__ns5__alert_info_area_geocode(struct soap*, const std::string& valueName, const std::string& value)` managed allocation with public members assigned the values of these parameters
- `void _ns5__alert_info_area_geocode::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns5__alert_info_area_geocode(struct soap*, const _ns5__alert_info_area_geocode*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns5__alert_info_area_geocode(struct soap*, const char *URL, const _ns5__alert_info_area_geocode*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns5__alert_info_area_geocode(struct soap*, const char *URL, const _ns5__alert_info_area_geocode*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns5__alert_info_area_geocode(struct soap*, const char *URL, const _ns5__alert_info_area_geocode*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns5__alert_info_area_geocode(struct soap*, _ns5__alert_info_area_geocode*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns5__alert_info_area_geocode(struct soap*, const char *URL, _ns5__alert_info_area_geocode*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns5__alert_info_area_geocode(struct soap*, _ns5__alert_info_area_geocode*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns5__alert_info_area"></a>

### `_ns5__alert_info_area`

This class is declared in [ipaws.h](ipaws.h) at line 635, is serialized as XML schema type *`ns5:alert-info-area`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns5__alert_info_area {
      public:
        /// Required element 'ns5:areaDesc' of XML schema type 'xsd:string'
        std::string areaDesc;
        /// Optional element 'ns5:polygon' of XML schema type 'xsd:string'
        std::vector<std::string> polygon;
        /// Optional element 'ns5:circle' of XML schema type 'xsd:string'
        std::vector<std::string> circle;
        /// Optional element 'ns5:geocode' of XML schema type 'ns5:alert-info-area-geocode'
        std::vector<_ns5__alert_info_area_geocode> geocode;
        /// Optional element 'ns5:altitude' of XML schema type 'xsd:decimal'
        std::string *altitude;
        /// Optional element 'ns5:ceiling' of XML schema type 'xsd:decimal'
        std::string *ceiling;
      public:
        /// Return unique type id SOAP_TYPE__ns5__alert_info_area
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__alert_info_area; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__alert_info_area, default initialized and not managed by a soap context
        virtual _ns5__alert_info_area *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns5__alert_info_area); }
      public:
        /// Constructor with default initializations
        _ns5__alert_info_area() : areaDesc(), polygon(), circle(), geocode(), altitude(), ceiling() { }
        virtual ~_ns5__alert_info_area() { }
        /// Friend allocator used by soap_new__ns5__alert_info_area(struct soap*, int)
        friend SOAP_FMAC1 _ns5__alert_info_area * SOAP_FMAC2 soap_instantiate__ns5__alert_info_area(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string areaDesc` is a required element *`<ns5:areaDesc>`* of XML schema type *`xsd:string`*
- `std::vector<std::string> polygon` is an optional element *`<ns5:polygon>`* of XML schema type *`xsd:string`*
- `std::vector<std::string> circle` is an optional element *`<ns5:circle>`* of XML schema type *`xsd:string`*
- `std::vector<_ns5__alert_info_area_geocode> geocode` is an optional element *`<ns5:geocode>`* of XML schema type *`ns5:alert-info-area-geocode`*, where the type of this member is a container of <code><a href="#_ns5__alert_info_area_geocode"> _ns5__alert_info_area_geocode </a></code>
- `std::string *altitude` is an optional element *`<ns5:altitude>`* of XML schema type *`xsd:decimal`*
- `std::string *ceiling` is an optional element *`<ns5:ceiling>`* of XML schema type *`xsd:decimal`*

The following operations on `_ns5__alert_info_area` are available:

- `_ns5__alert_info_area *soap_new__ns5__alert_info_area(struct soap*)` managed allocation with default initialization
- `_ns5__alert_info_area *soap_new__ns5__alert_info_area(struct soap*, int n)` managed allocation of array `_ns5__alert_info_area[n]`
- `_ns5__alert_info_area *soap_new_req__ns5__alert_info_area(struct soap*, const std::string& areaDesc)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns5__alert_info_area *soap_new_set__ns5__alert_info_area(struct soap*, const std::string& areaDesc, const std::vector<std::string> & polygon, const std::vector<std::string> & circle, const std::vector<_ns5__alert_info_area_geocode> & geocode, std::string *altitude, std::string *ceiling)` managed allocation with public members assigned the values of these parameters
- `void _ns5__alert_info_area::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns5__alert_info_area(struct soap*, const _ns5__alert_info_area*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns5__alert_info_area(struct soap*, const char *URL, const _ns5__alert_info_area*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns5__alert_info_area(struct soap*, const char *URL, const _ns5__alert_info_area*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns5__alert_info_area(struct soap*, const char *URL, const _ns5__alert_info_area*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns5__alert_info_area(struct soap*, _ns5__alert_info_area*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns5__alert_info_area(struct soap*, const char *URL, _ns5__alert_info_area*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns5__alert_info_area(struct soap*, _ns5__alert_info_area*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns5__alert_info"></a>

### `_ns5__alert_info`

This class is declared in [ipaws.h](ipaws.h) at line 465, is serialized as XML schema type *`ns5:alert-info`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns5__alert_info {
      public:
        /// Optional element 'ns5:language' of XML schema type 'xsd:language'
        std::string *language;	///< optional with default value = "en-US"
        /// Required element 'ns5:category' of XML schema type 'ns5:alert-info-category'
        std::vector<enum _ns5__alert_info_category> category;
        /// Required element 'ns5:event' of XML schema type 'xsd:string'
        std::string event;
        /// Optional element 'ns5:responseType' of XML schema type 'ns5:alert-info-responseType'
        std::vector<enum _ns5__alert_info_responseType> responseType;
        /// Required element 'ns5:urgency' of XML schema type 'ns5:alert-info-urgency'
        enum _ns5__alert_info_urgency urgency;
        /// Required element 'ns5:severity' of XML schema type 'ns5:alert-info-severity'
        enum _ns5__alert_info_severity severity;
        /// Required element 'ns5:certainty' of XML schema type 'ns5:alert-info-certainty'
        enum _ns5__alert_info_certainty certainty;
        /// Optional element 'ns5:audience' of XML schema type 'xsd:string'
        std::string *audience;
        /// Optional element 'ns5:eventCode' of XML schema type 'ns5:alert-info-eventCode'
        std::vector<_ns5__alert_info_eventCode> eventCode;
        /// Optional element 'ns5:effective' of XML schema type 'xsd:dateTime'
        time_t *effective;
        /// Optional element 'ns5:onset' of XML schema type 'xsd:dateTime'
        time_t *onset;
        /// Optional element 'ns5:expires' of XML schema type 'xsd:dateTime'
        time_t *expires;
        /// Optional element 'ns5:senderName' of XML schema type 'xsd:string'
        std::string *senderName;
        /// Optional element 'ns5:headline' of XML schema type 'xsd:string'
        std::string *headline;
        /// Optional element 'ns5:description' of XML schema type 'xsd:string'
        std::string *description;
        /// Optional element 'ns5:instruction' of XML schema type 'xsd:string'
        std::string *instruction;
        /// Optional element 'ns5:web' of XML schema type 'xsd:anyURI'
        std::string *web;
        /// Optional element 'ns5:contact' of XML schema type 'xsd:string'
        std::string *contact;
        /// Optional element 'ns5:parameter' of XML schema type 'ns5:alert-info-parameter'
        std::vector<_ns5__alert_info_parameter> parameter;
        /// Optional element 'ns5:resource' of XML schema type 'ns5:alert-info-resource'
        std::vector<_ns5__alert_info_resource> resource;
        /// Optional element 'ns5:area' of XML schema type 'ns5:alert-info-area'
        std::vector<_ns5__alert_info_area> area;
      public:
        /// Return unique type id SOAP_TYPE__ns5__alert_info
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__alert_info; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__alert_info, default initialized and not managed by a soap context
        virtual _ns5__alert_info *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns5__alert_info); }
      public:
        /// Constructor with default initializations
        _ns5__alert_info() : language(), category(), event(), responseType(), urgency(), severity(), certainty(), audience(), eventCode(), effective(), onset(), expires(), senderName(), headline(), description(), instruction(), web(), contact(), parameter(), resource(), area() { }
        virtual ~_ns5__alert_info() { }
        /// Friend allocator used by soap_new__ns5__alert_info(struct soap*, int)
        friend SOAP_FMAC1 _ns5__alert_info * SOAP_FMAC2 soap_instantiate__ns5__alert_info(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *language` is an optional element *`<ns5:language>`* of XML schema type *`xsd:language`* that has default value `"en-US"`
- `std::vector<enum _ns5__alert_info_category> category` is a required element *`<ns5:category>`* of XML schema type *`ns5:alert-info-category`*, where the type of this member is a container of <code><a href="#_ns5__alert_info_category"> _ns5__alert_info_category </a></code>
- `std::string event` is a required element *`<ns5:event>`* of XML schema type *`xsd:string`*
- `std::vector<enum _ns5__alert_info_responseType> responseType` is an optional element *`<ns5:responseType>`* of XML schema type *`ns5:alert-info-responseType`*, where the type of this member is a container of <code><a href="#_ns5__alert_info_responseType"> _ns5__alert_info_responseType </a></code>
- `enum _ns5__alert_info_urgency urgency` is a required element *`<ns5:urgency>`* of XML schema type *`ns5:alert-info-urgency`*, where the type of this member is <code><a href="#_ns5__alert_info_urgency"> _ns5__alert_info_urgency </a></code>
- `enum _ns5__alert_info_severity severity` is a required element *`<ns5:severity>`* of XML schema type *`ns5:alert-info-severity`*, where the type of this member is <code><a href="#_ns5__alert_info_severity"> _ns5__alert_info_severity </a></code>
- `enum _ns5__alert_info_certainty certainty` is a required element *`<ns5:certainty>`* of XML schema type *`ns5:alert-info-certainty`*, where the type of this member is <code><a href="#_ns5__alert_info_certainty"> _ns5__alert_info_certainty </a></code>
- `std::string *audience` is an optional element *`<ns5:audience>`* of XML schema type *`xsd:string`*
- `std::vector<_ns5__alert_info_eventCode> eventCode` is an optional element *`<ns5:eventCode>`* of XML schema type *`ns5:alert-info-eventCode`*, where the type of this member is a container of <code><a href="#_ns5__alert_info_eventCode"> _ns5__alert_info_eventCode </a></code>
- `time_t *effective` is an optional element *`<ns5:effective>`* of XML schema type *`xsd:dateTime`*
- `time_t *onset` is an optional element *`<ns5:onset>`* of XML schema type *`xsd:dateTime`*
- `time_t *expires` is an optional element *`<ns5:expires>`* of XML schema type *`xsd:dateTime`*
- `std::string *senderName` is an optional element *`<ns5:senderName>`* of XML schema type *`xsd:string`*
- `std::string *headline` is an optional element *`<ns5:headline>`* of XML schema type *`xsd:string`*
- `std::string *description` is an optional element *`<ns5:description>`* of XML schema type *`xsd:string`*
- `std::string *instruction` is an optional element *`<ns5:instruction>`* of XML schema type *`xsd:string`*
- `std::string *web` is an optional element *`<ns5:web>`* of XML schema type *`xsd:anyURI`*
- `std::string *contact` is an optional element *`<ns5:contact>`* of XML schema type *`xsd:string`*
- `std::vector<_ns5__alert_info_parameter> parameter` is an optional element *`<ns5:parameter>`* of XML schema type *`ns5:alert-info-parameter`*, where the type of this member is a container of <code><a href="#_ns5__alert_info_parameter"> _ns5__alert_info_parameter </a></code>
- `std::vector<_ns5__alert_info_resource> resource` is an optional element *`<ns5:resource>`* of XML schema type *`ns5:alert-info-resource`*, where the type of this member is a container of <code><a href="#_ns5__alert_info_resource"> _ns5__alert_info_resource </a></code>
- `std::vector<_ns5__alert_info_area> area` is an optional element *`<ns5:area>`* of XML schema type *`ns5:alert-info-area`*, where the type of this member is a container of <code><a href="#_ns5__alert_info_area"> _ns5__alert_info_area </a></code>

The following operations on `_ns5__alert_info` are available:

- `_ns5__alert_info *soap_new__ns5__alert_info(struct soap*)` managed allocation with default initialization
- `_ns5__alert_info *soap_new__ns5__alert_info(struct soap*, int n)` managed allocation of array `_ns5__alert_info[n]`
- `_ns5__alert_info *soap_new_req__ns5__alert_info(struct soap*, const std::vector<enum _ns5__alert_info_category> & category, const std::string& event, enum _ns5__alert_info_urgency urgency, enum _ns5__alert_info_severity severity, enum _ns5__alert_info_certainty certainty)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns5__alert_info *soap_new_set__ns5__alert_info(struct soap*, std::string *language, const std::vector<enum _ns5__alert_info_category> & category, const std::string& event, const std::vector<enum _ns5__alert_info_responseType> & responseType, enum _ns5__alert_info_urgency urgency, enum _ns5__alert_info_severity severity, enum _ns5__alert_info_certainty certainty, std::string *audience, const std::vector<_ns5__alert_info_eventCode> & eventCode, time_t *effective, time_t *onset, time_t *expires, std::string *senderName, std::string *headline, std::string *description, std::string *instruction, std::string *web, std::string *contact, const std::vector<_ns5__alert_info_parameter> & parameter, const std::vector<_ns5__alert_info_resource> & resource, const std::vector<_ns5__alert_info_area> & area)` managed allocation with public members assigned the values of these parameters
- `void _ns5__alert_info::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns5__alert_info(struct soap*, const _ns5__alert_info*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns5__alert_info(struct soap*, const char *URL, const _ns5__alert_info*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns5__alert_info(struct soap*, const char *URL, const _ns5__alert_info*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns5__alert_info(struct soap*, const char *URL, const _ns5__alert_info*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns5__alert_info(struct soap*, _ns5__alert_info*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns5__alert_info(struct soap*, const char *URL, _ns5__alert_info*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns5__alert_info(struct soap*, _ns5__alert_info*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns5__alert"></a>

### `_ns5__alert`

This class is declared in [ipaws.h](ipaws.h) at line 192, is serialized as XML schema type *`ns5:alert`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns5__alert {
      public:
        /// Required element 'ns5:identifier' of XML schema type 'xsd:string'
        std::string identifier;
        /// Required element 'ns5:sender' of XML schema type 'xsd:string'
        std::string sender;
        /// Required element 'ns5:sent' of XML schema type 'xsd:dateTime'
        time_t sent;
        /// Required element 'ns5:status' of XML schema type 'ns5:alert-status'
        enum _ns5__alert_status status;
        /// Required element 'ns5:msgType' of XML schema type 'ns5:alert-msgType'
        enum _ns5__alert_msgType msgType;
        /// Optional element 'ns5:source' of XML schema type 'xsd:string'
        std::string *source;
        /// Required element 'ns5:scope' of XML schema type 'ns5:alert-scope'
        enum _ns5__alert_scope scope;
        /// Optional element 'ns5:restriction' of XML schema type 'xsd:string'
        std::string *restriction;
        /// Optional element 'ns5:addresses' of XML schema type 'xsd:string'
        std::string *addresses;
        /// Optional element 'ns5:code' of XML schema type 'xsd:string'
        std::vector<std::string> code;
        /// Optional element 'ns5:note' of XML schema type 'xsd:string'
        std::string *note;
        /// Optional element 'ns5:references' of XML schema type 'xsd:string'
        std::string *references;
        /// Optional element 'ns5:incidents' of XML schema type 'xsd:string'
        std::string *incidents;
        /// Optional element 'ns5:info' of XML schema type 'ns5:alert-info'
        std::vector<_ns5__alert_info> info;
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns5__alert
        virtual long soap_type(void) const { return SOAP_TYPE__ns5__alert; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns5__alert, default initialized and not managed by a soap context
        virtual _ns5__alert *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns5__alert); }
      public:
        /// Constructor with default initializations
        _ns5__alert() : identifier(), sender(), sent(), status(), msgType(), source(), scope(), restriction(), addresses(), code(), note(), references(), incidents(), info(), __any(), soap() { }
        virtual ~_ns5__alert() { }
        /// Friend allocator used by soap_new__ns5__alert(struct soap*, int)
        friend SOAP_FMAC1 _ns5__alert * SOAP_FMAC2 soap_instantiate__ns5__alert(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string identifier` is a required element *`<ns5:identifier>`* of XML schema type *`xsd:string`*
- `std::string sender` is a required element *`<ns5:sender>`* of XML schema type *`xsd:string`*
- `time_t sent` is a required element *`<ns5:sent>`* of XML schema type *`xsd:dateTime`*
- `enum _ns5__alert_status status` is a required element *`<ns5:status>`* of XML schema type *`ns5:alert-status`*, where the type of this member is <code><a href="#_ns5__alert_status"> _ns5__alert_status </a></code>
- `enum _ns5__alert_msgType msgType` is a required element *`<ns5:msgType>`* of XML schema type *`ns5:alert-msgType`*, where the type of this member is <code><a href="#_ns5__alert_msgType"> _ns5__alert_msgType </a></code>
- `std::string *source` is an optional element *`<ns5:source>`* of XML schema type *`xsd:string`*
- `enum _ns5__alert_scope scope` is a required element *`<ns5:scope>`* of XML schema type *`ns5:alert-scope`*, where the type of this member is <code><a href="#_ns5__alert_scope"> _ns5__alert_scope </a></code>
- `std::string *restriction` is an optional element *`<ns5:restriction>`* of XML schema type *`xsd:string`*
- `std::string *addresses` is an optional element *`<ns5:addresses>`* of XML schema type *`xsd:string`*
- `std::vector<std::string> code` is an optional element *`<ns5:code>`* of XML schema type *`xsd:string`*
- `std::string *note` is an optional element *`<ns5:note>`* of XML schema type *`xsd:string`*
- `std::string *references` is an optional element *`<ns5:references>`* of XML schema type *`xsd:string`*
- `std::string *incidents` is an optional element *`<ns5:incidents>`* of XML schema type *`xsd:string`*
- `std::vector<_ns5__alert_info> info` is an optional element *`<ns5:info>`* of XML schema type *`ns5:alert-info`*, where the type of this member is a container of <code><a href="#_ns5__alert_info"> _ns5__alert_info </a></code>
- `std::vector<char *> __any` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `struct soap *soap` the context that manages this object

The following operations on `_ns5__alert` are available:

- `_ns5__alert *soap_new__ns5__alert(struct soap*)` managed allocation with default initialization
- `_ns5__alert *soap_new__ns5__alert(struct soap*, int n)` managed allocation of array `_ns5__alert[n]`
- `_ns5__alert *soap_new_req__ns5__alert(struct soap*, const std::string& identifier, const std::string& sender, time_t sent, enum _ns5__alert_status status, enum _ns5__alert_msgType msgType, enum _ns5__alert_scope scope)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns5__alert *soap_new_set__ns5__alert(struct soap*, const std::string& identifier, const std::string& sender, time_t sent, enum _ns5__alert_status status, enum _ns5__alert_msgType msgType, std::string *source, enum _ns5__alert_scope scope, std::string *restriction, std::string *addresses, const std::vector<std::string> & code, std::string *note, std::string *references, std::string *incidents, const std::vector<_ns5__alert_info> & info, const std::vector<char *> & __any)` managed allocation with public members assigned the values of these parameters
- `void _ns5__alert::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns5__alert(struct soap*, const _ns5__alert*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns5__alert(struct soap*, const char *URL, const _ns5__alert*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns5__alert(struct soap*, const char *URL, const _ns5__alert*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns5__alert(struct soap*, const char *URL, const _ns5__alert*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns5__alert(struct soap*, _ns5__alert*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns5__alert(struct soap*, const char *URL, _ns5__alert*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns5__alert(struct soap*, _ns5__alert*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns2__postCAPRequestTypeDef"></a>

### `_ns2__postCAPRequestTypeDef`

This class is declared in [ipaws.h](ipaws.h) at line 194, is serialized as XML schema type *`ns2:postCAPRequestTypeDef`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns2__postCAPRequestTypeDef {
      public:
        /// Required element 'ns5:alert' of XML schema type 'ns5:alert'
        _ns5__alert *ns5__alert;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__postCAPRequestTypeDef
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__postCAPRequestTypeDef; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__postCAPRequestTypeDef, default initialized and not managed by a soap context
        virtual _ns2__postCAPRequestTypeDef *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__postCAPRequestTypeDef); }
      public:
        /// Constructor with default initializations
        _ns2__postCAPRequestTypeDef() : ns5__alert(), soap() { }
        virtual ~_ns2__postCAPRequestTypeDef() { }
        /// Friend allocator used by soap_new__ns2__postCAPRequestTypeDef(struct soap*, int)
        friend SOAP_FMAC1 _ns2__postCAPRequestTypeDef * SOAP_FMAC2 soap_instantiate__ns2__postCAPRequestTypeDef(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `_ns5__alert *ns5__alert` is a required element *`<ns5:alert>`* of XML schema type *`ns5:alert`*, where the type of this member is a pointer to <code><a href="#_ns5__alert"> _ns5__alert </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `_ns2__postCAPRequestTypeDef` are available:

- `_ns2__postCAPRequestTypeDef *soap_new__ns2__postCAPRequestTypeDef(struct soap*)` managed allocation with default initialization
- `_ns2__postCAPRequestTypeDef *soap_new__ns2__postCAPRequestTypeDef(struct soap*, int n)` managed allocation of array `_ns2__postCAPRequestTypeDef[n]`
- `_ns2__postCAPRequestTypeDef *soap_new_req__ns2__postCAPRequestTypeDef(struct soap*, _ns5__alert *ns5__alert)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns2__postCAPRequestTypeDef *soap_new_set__ns2__postCAPRequestTypeDef(struct soap*, _ns5__alert *ns5__alert)` managed allocation with public members assigned the values of these parameters
- `void _ns2__postCAPRequestTypeDef::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns2__postCAPRequestTypeDef(struct soap*, const _ns2__postCAPRequestTypeDef*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns2__postCAPRequestTypeDef(struct soap*, const char *URL, const _ns2__postCAPRequestTypeDef*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns2__postCAPRequestTypeDef(struct soap*, const char *URL, const _ns2__postCAPRequestTypeDef*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns2__postCAPRequestTypeDef(struct soap*, const char *URL, const _ns2__postCAPRequestTypeDef*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns2__postCAPRequestTypeDef(struct soap*, _ns2__postCAPRequestTypeDef*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns2__postCAPRequestTypeDef(struct soap*, const char *URL, _ns2__postCAPRequestTypeDef*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns2__postCAPRequestTypeDef(struct soap*, _ns2__postCAPRequestTypeDef*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns2__CAPServiceException"></a>

### `_ns2__CAPServiceException`

This class is declared in [ipaws.h](ipaws.h) at line 196, is serialized as XML schema type *`ns2:CAPServiceException`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns2__CAPServiceException {
      public:
        /// Required nillable (xsi:nil when NULL) element 'ns2:errorCode' of XML schema type 'xsd:string'
        std::string *errorCode;
        /// Required nillable (xsi:nil when NULL) element 'ns2:message' of XML schema type 'xsd:string'
        std::string *message;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__CAPServiceException
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__CAPServiceException; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__CAPServiceException, default initialized and not managed by a soap context
        virtual _ns2__CAPServiceException *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__CAPServiceException); }
      public:
        /// Constructor with default initializations
        _ns2__CAPServiceException() : errorCode(), message(), soap() { }
        virtual ~_ns2__CAPServiceException() { }
        /// Friend allocator used by soap_new__ns2__CAPServiceException(struct soap*, int)
        friend SOAP_FMAC1 _ns2__CAPServiceException * SOAP_FMAC2 soap_instantiate__ns2__CAPServiceException(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *errorCode` is a required nillable (xsi:nil when NULL) element *`<ns2:errorCode>`* of XML schema type *`xsd:string`*
- `std::string *message` is a required nillable (xsi:nil when NULL) element *`<ns2:message>`* of XML schema type *`xsd:string`*
- `struct soap *soap` the context that manages this object

The following operations on `_ns2__CAPServiceException` are available:

- `_ns2__CAPServiceException *soap_new__ns2__CAPServiceException(struct soap*)` managed allocation with default initialization
- `_ns2__CAPServiceException *soap_new__ns2__CAPServiceException(struct soap*, int n)` managed allocation of array `_ns2__CAPServiceException[n]`
- `_ns2__CAPServiceException *soap_new_req__ns2__CAPServiceException(struct soap*, std::string *errorCode, std::string *message)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns2__CAPServiceException *soap_new_set__ns2__CAPServiceException(struct soap*, std::string *errorCode, std::string *message)` managed allocation with public members assigned the values of these parameters
- `void _ns2__CAPServiceException::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns2__CAPServiceException(struct soap*, const _ns2__CAPServiceException*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns2__CAPServiceException(struct soap*, const char *URL, const _ns2__CAPServiceException*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns2__CAPServiceException(struct soap*, const char *URL, const _ns2__CAPServiceException*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns2__CAPServiceException(struct soap*, const char *URL, const _ns2__CAPServiceException*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns2__CAPServiceException(struct soap*, _ns2__CAPServiceException*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns2__CAPServiceException(struct soap*, const char *URL, _ns2__CAPServiceException*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns2__CAPServiceException(struct soap*, _ns2__CAPServiceException*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns2__postCAPResponseTypeDef"></a>

### `_ns2__postCAPResponseTypeDef`

This class is declared in [ipaws.h](ipaws.h) at line 198, is serialized as XML schema type *`ns2:postCAPResponseTypeDef`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns2__postCAPResponseTypeDef {
      public:
        /// Required nillable (xsi:nil when NULL) element 'ns2:postCAPReturn' of XML schema type 'xsd:string'
        std::string *postCAPReturn;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__postCAPResponseTypeDef
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__postCAPResponseTypeDef; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__postCAPResponseTypeDef, default initialized and not managed by a soap context
        virtual _ns2__postCAPResponseTypeDef *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__postCAPResponseTypeDef); }
      public:
        /// Constructor with default initializations
        _ns2__postCAPResponseTypeDef() : postCAPReturn(), soap() { }
        virtual ~_ns2__postCAPResponseTypeDef() { }
        /// Friend allocator used by soap_new__ns2__postCAPResponseTypeDef(struct soap*, int)
        friend SOAP_FMAC1 _ns2__postCAPResponseTypeDef * SOAP_FMAC2 soap_instantiate__ns2__postCAPResponseTypeDef(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *postCAPReturn` is a required nillable (xsi:nil when NULL) element *`<ns2:postCAPReturn>`* of XML schema type *`xsd:string`*
- `struct soap *soap` the context that manages this object

The following operations on `_ns2__postCAPResponseTypeDef` are available:

- `_ns2__postCAPResponseTypeDef *soap_new__ns2__postCAPResponseTypeDef(struct soap*)` managed allocation with default initialization
- `_ns2__postCAPResponseTypeDef *soap_new__ns2__postCAPResponseTypeDef(struct soap*, int n)` managed allocation of array `_ns2__postCAPResponseTypeDef[n]`
- `_ns2__postCAPResponseTypeDef *soap_new_req__ns2__postCAPResponseTypeDef(struct soap*, std::string *postCAPReturn)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns2__postCAPResponseTypeDef *soap_new_set__ns2__postCAPResponseTypeDef(struct soap*, std::string *postCAPReturn)` managed allocation with public members assigned the values of these parameters
- `void _ns2__postCAPResponseTypeDef::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns2__postCAPResponseTypeDef(struct soap*, const _ns2__postCAPResponseTypeDef*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns2__postCAPResponseTypeDef(struct soap*, const char *URL, const _ns2__postCAPResponseTypeDef*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns2__postCAPResponseTypeDef(struct soap*, const char *URL, const _ns2__postCAPResponseTypeDef*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns2__postCAPResponseTypeDef(struct soap*, const char *URL, const _ns2__postCAPResponseTypeDef*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns2__postCAPResponseTypeDef(struct soap*, _ns2__postCAPResponseTypeDef*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns2__postCAPResponseTypeDef(struct soap*, const char *URL, _ns2__postCAPResponseTypeDef*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns2__postCAPResponseTypeDef(struct soap*, _ns2__postCAPResponseTypeDef*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns2__messageResponseTypeDef"></a>

### `_ns2__messageResponseTypeDef`

This class is declared in [ipaws.h](ipaws.h) at line 200, is serialized as XML schema type *`ns2:messageResponseTypeDef`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns2__messageResponseTypeDef {
      public:
        /// Optional element 'ns5:alert' of XML schema type 'ns5:alert'
        std::vector<_ns5__alert *> ns5__alert;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__messageResponseTypeDef
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__messageResponseTypeDef; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__messageResponseTypeDef, default initialized and not managed by a soap context
        virtual _ns2__messageResponseTypeDef *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__messageResponseTypeDef); }
      public:
        /// Constructor with default initializations
        _ns2__messageResponseTypeDef() : ns5__alert(), soap() { }
        virtual ~_ns2__messageResponseTypeDef() { }
        /// Friend allocator used by soap_new__ns2__messageResponseTypeDef(struct soap*, int)
        friend SOAP_FMAC1 _ns2__messageResponseTypeDef * SOAP_FMAC2 soap_instantiate__ns2__messageResponseTypeDef(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::vector<_ns5__alert *> ns5__alert` is an optional element *`<ns5:alert>`* of XML schema type *`ns5:alert`*, where the type of this member is a container of pointers to <code><a href="#_ns5__alert"> _ns5__alert </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `_ns2__messageResponseTypeDef` are available:

- `_ns2__messageResponseTypeDef *soap_new__ns2__messageResponseTypeDef(struct soap*)` managed allocation with default initialization
- `_ns2__messageResponseTypeDef *soap_new__ns2__messageResponseTypeDef(struct soap*, int n)` managed allocation of array `_ns2__messageResponseTypeDef[n]`
- `_ns2__messageResponseTypeDef *soap_new_req__ns2__messageResponseTypeDef(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns2__messageResponseTypeDef *soap_new_set__ns2__messageResponseTypeDef(struct soap*, const std::vector<_ns5__alert *> & ns5__alert)` managed allocation with public members assigned the values of these parameters
- `void _ns2__messageResponseTypeDef::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns2__messageResponseTypeDef(struct soap*, const _ns2__messageResponseTypeDef*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns2__messageResponseTypeDef(struct soap*, const char *URL, const _ns2__messageResponseTypeDef*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns2__messageResponseTypeDef(struct soap*, const char *URL, const _ns2__messageResponseTypeDef*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns2__messageResponseTypeDef(struct soap*, const char *URL, const _ns2__messageResponseTypeDef*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns2__messageResponseTypeDef(struct soap*, _ns2__messageResponseTypeDef*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns2__messageResponseTypeDef(struct soap*, const char *URL, _ns2__messageResponseTypeDef*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns2__messageResponseTypeDef(struct soap*, _ns2__messageResponseTypeDef*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns2__CAPHeaderTypeDef"></a>

### `_ns2__CAPHeaderTypeDef`

This class is declared in [ipaws.h](ipaws.h) at line 202, is serialized as XML schema type *`ns2:CAPHeaderTypeDef`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns2__CAPHeaderTypeDef {
      public:
        /// Optional element 'ns2:logonUser' of XML schema type 'xsd:string'
        std::string *logonUser;
        /// Optional element 'ns2:logonCogId' of XML schema type 'xsd:int'
        int *logonCogId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns2__CAPHeaderTypeDef
        virtual long soap_type(void) const { return SOAP_TYPE__ns2__CAPHeaderTypeDef; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns2__CAPHeaderTypeDef, default initialized and not managed by a soap context
        virtual _ns2__CAPHeaderTypeDef *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns2__CAPHeaderTypeDef); }
      public:
        /// Constructor with default initializations
        _ns2__CAPHeaderTypeDef() : logonUser(), logonCogId(), soap() { }
        virtual ~_ns2__CAPHeaderTypeDef() { }
        /// Friend allocator used by soap_new__ns2__CAPHeaderTypeDef(struct soap*, int)
        friend SOAP_FMAC1 _ns2__CAPHeaderTypeDef * SOAP_FMAC2 soap_instantiate__ns2__CAPHeaderTypeDef(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `std::string *logonUser` is an optional element *`<ns2:logonUser>`* of XML schema type *`xsd:string`*
- `int *logonCogId` is an optional element *`<ns2:logonCogId>`* of XML schema type *`xsd:int`*
- `struct soap *soap` the context that manages this object

The following operations on `_ns2__CAPHeaderTypeDef` are available:

- `_ns2__CAPHeaderTypeDef *soap_new__ns2__CAPHeaderTypeDef(struct soap*)` managed allocation with default initialization
- `_ns2__CAPHeaderTypeDef *soap_new__ns2__CAPHeaderTypeDef(struct soap*, int n)` managed allocation of array `_ns2__CAPHeaderTypeDef[n]`
- `_ns2__CAPHeaderTypeDef *soap_new_req__ns2__CAPHeaderTypeDef(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns2__CAPHeaderTypeDef *soap_new_set__ns2__CAPHeaderTypeDef(struct soap*, std::string *logonUser, int *logonCogId)` managed allocation with public members assigned the values of these parameters
- `void _ns2__CAPHeaderTypeDef::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns2__CAPHeaderTypeDef(struct soap*, const _ns2__CAPHeaderTypeDef*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns2__CAPHeaderTypeDef(struct soap*, const char *URL, const _ns2__CAPHeaderTypeDef*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns2__CAPHeaderTypeDef(struct soap*, const char *URL, const _ns2__CAPHeaderTypeDef*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns2__CAPHeaderTypeDef(struct soap*, const char *URL, const _ns2__CAPHeaderTypeDef*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns2__CAPHeaderTypeDef(struct soap*, _ns2__CAPHeaderTypeDef*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns2__CAPHeaderTypeDef(struct soap*, const char *URL, _ns2__CAPHeaderTypeDef*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns2__CAPHeaderTypeDef(struct soap*, _ns2__CAPHeaderTypeDef*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="SOAP_ENV__Header"></a>

### `struct SOAP_ENV__Header`

This struct is declared in [ipaws.h](ipaws.h) at line 960, is the SOAP protocol *`<SOAP-ENV:Header>`* element with message-specific child elements that are mandatory to process when attributed with *`mustUnderstand="true"`*.  Headers are usually added and processed by plugins.  To remove the SOAP Header when sending or returning a message, set `soap->header = NULL`.  Use `soap_header(struct soap *soap)` to allocate a `struct SOAP_ENV__Header` which will be pointed to by `soap->header`, then initialize it with `soap_default_SOAP_ENV__Header(soap, soap->header)` and set one or more of its data members (if any):

- `_ns2__CAPHeaderTypeDef *ns2__CAPHeaderTypeDef` element ns2:CAPHeaderTypeDef with mustUnderstand="true">


This struct will be auto-generated when it is not explicitly declared in an interface header file, and is declared mutable, meaning that multiple declarations in interface header files are collected into one structure, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** MustUnderstand */
        _ns2__CAPHeaderTypeDef *ns2__CAPHeaderTypeDef;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() : ns2__CAPHeaderTypeDef() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
    };

[![][1] To top](#)


<a name="SOAP_ENV__Detail"></a>

### `struct SOAP_ENV__Detail`

This struct is declared in [ipaws.h](ipaws.h) at line 983, is the SOAP protocol *`<SOAP-ENV:Detail>`* element with details returned by a service that triggered the error.  Fault details are added and processed by plugins by setting the `detail` (for SOAP 1.1) or `SOAP_ENV__Detail` (for SOAP 1.2) member of `struct SOAP_ENV__Fault` and then setting one ore more of the detail members:

- `_ns2__CAPServiceException *ns2__CAPServiceException` element *`<ns2:CAPServiceException>`*
- `int __type` element *`<fault>`* serialized with C/C++ type `__type` = `SOAP_TYPE_<Type>`
- `char *__any` catch-all XML in literal XML string, see also <code><a href="#_XML"> _XML </a></code>


This struct will be auto-generated when it is not explicitly declared in an interface header file, and is declared mutable, meaning that multiple declarations in interface header files are collected into one structure, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        /** Optional element 'ns2:CAPServiceException' of XML schema type 'ns2:CAPServiceException' */
        _ns2__CAPServiceException *ns2__CAPServiceException;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
        char *__any;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : ns2__CAPServiceException(), __type(), fault(), __any() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
    };

[![][1] To top](#)


<a name="__ns2__getRequest"></a>

### `struct __ns2__getRequest`

This struct is declared in [ipaws.h](ipaws.h) at line 1076, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns2__getRequest()`.

[![][1] To top](#)


<a name="__ns2__postCAP"></a>

### `struct __ns2__postCAP`

This struct is declared in [ipaws.h](ipaws.h) at line 1153, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns2__postCAP()`.

[![][1] To top](#)


<a name="__ns2__getMessage"></a>

### `struct __ns2__getMessage`

This struct is declared in [ipaws.h](ipaws.h) at line 1230, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns2__getMessage()`.

[![][1] To top](#)


<a name="SOAP_ENV__Code"></a>

### `struct SOAP_ENV__Code`

This struct is declared in [ipaws.h](ipaws.h) at line 1412, is recursive, meaning it may (in)directly reference itself through its (base or derived class) members, and is the SOAP protocol *`<SOAP-ENV:Code>`* element.  This struct is for internal use and will be auto-generated when not explicitly declared.

[![][1] To top](#)


<a name="SOAP_ENV__Reason"></a>

### `struct SOAP_ENV__Reason`

This struct is declared in [ipaws.h](ipaws.h) at line 1412, is the SOAP protocol *`<SOAP-ENV:Reason>`* element.  This struct is for internal use and will be auto-generated when not explicitly declared.

[![][1] To top](#)


<a name="SOAP_ENV__Fault"></a>

### `struct SOAP_ENV__Fault`

This struct is declared in [ipaws.h](ipaws.h) at line 1412, is the SOAP protocol *`<SOAP-ENV:Fault>`* element with fault information and details returned by a service that triggered the error.  At the server side, a fault can be explicitly set within a service operation by calling and returning:

- `int soap_sender_fault(struct soap *soap, const char *faultstring, const char *XML)` return this error code when the sender is at fault (irrecoverable)
- `int soap_receiver_fault(struct soap *soap, const char *faultstring, const char *XML)` return this error code when the receiver is at fault (recoverable, sender may retry)

A service operation may also return an HTTP status or error code (200 to 599).

At the client side the (proxy) call returns the error code which is also stored in `soap->error`.  The fault structure is pointed to by `soap->fault`.  The fault can be displayed with:

- `void soap_print_fault(struct soap *soap, FILE *fd)` display fault
- `void soap_print_fault_location(struct soap *soap, FILE *fd)` display the location of the fault in the XML message that caused it
- `void soap_sprint_fault(struct soap *soap, char *buf, size_t len)` write fault to buffer
- `void soap_stream_fault(struct soap *soap, std::ostream&)` write fault to stream
- `const char *soap_fault_subcode(struct soap *soap)` returns the SOAP Fault subcode QName string or NULL when absent
- `const char *soap_fault_string(struct soap *soap)` returns the SOAP Fault string/reason or NULL when absent
- `const char *soap_fault_detail(struct soap *soap)` returns the SOAP Fault detail XML string or NULL when absent
- `const char **soap_faultsubcode(struct soap *soap)` returns a pointer to the SOAP Fault to set this QName string
- `const char **soap_faultstring(struct soap *soap)` returns a pointer to the SOAP Fault string/reason to set this string
- `const char **soap_faultdetail(struct soap *soap)` returns a pointer to the SOAP Fault detail XML string to set this string or returns NULL when not accessible

This struct will be auto-generated when it is not explicitly declared in an interface header file and is declared mutable, meaning that multiple declarations in interface header files are collected into one structure, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
    };

[![][1] To top](#)


## Typedefs {#doc-typedefs}

A typedef type is serializable if its underlying base type is serializable.  Typedefs may declare custom serializers, meaning their underlying types are custom-serialized in XML using serialization rules that differ from the serialization rules of the underlying base type:
<table class="doxtable">
<tr><th> Typedef </th><th> Type </th><th> Declared </th><th> Serializable </th><th> Custom </th></tr>
<tr><td><code><a href="#_XML"> _XML </a></code></td><td><code> char * </code></td><td> (built-in):0 </td><td> yes </td><td> yes </td></tr>
<tr><td><code><a href="#_QName"> _QName </a></code></td><td><code> char * </code></td><td> (built-in):0 </td><td> yes </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__anyURI"> xsd__anyURI </a></code></td><td><code> std::string </code></td><td> ipaws.h:163 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#xsd__decimal"> xsd__decimal </a></code></td><td><code> std::string </code></td><td> ipaws.h:166 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#xsd__integer"> xsd__integer </a></code></td><td><code> std::string </code></td><td> ipaws.h:169 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#xsd__language"> xsd__language </a></code></td><td><code> std::string </code></td><td> ipaws.h:172 </td><td> yes </td><td>  </td></tr>
</table>

<a name="_XML"></a>

### `_XML`

This typedef is internally generated and is a built-in string type to hold XML that is literally serialized to and from XML

[![][1] To top](#)


<a name="_QName"></a>

### `_QName`

This typedef is internally generated and is a built-in string type to serialize a list of space-separated qualified names (*`xsd:QName`*), such that XML namespace prefixes are normalized to the XML prefixes defined in the [namespace table](#doc-namespaces) or replaced with "URI": when the namespace table has no prefix entry for the URI

[![][1] To top](#)


<a name="xsd__anyURI"></a>

### `xsd__anyURI`

This typedef is declared in [ipaws.h](ipaws.h) at line 163, is serialized as XML schema type *`xsd:anyURI`* and has underlying base type `std::string`

[![][1] To top](#)


<a name="xsd__decimal"></a>

### `xsd__decimal`

This typedef is declared in [ipaws.h](ipaws.h) at line 166, is serialized as XML schema type *`xsd:decimal`* and has underlying base type `std::string`, which should be

- matching regex pattern "[-+]?(\d+|\d*\.\d*)"

[![][1] To top](#)


<a name="xsd__integer"></a>

### `xsd__integer`

This typedef is declared in [ipaws.h](ipaws.h) at line 169, is serialized as XML schema type *`xsd:integer`* and has underlying base type `std::string`, which should be

- matching regex pattern "[-+]?\d+"

[![][1] To top](#)


<a name="xsd__language"></a>

### `xsd__language`

This typedef is declared in [ipaws.h](ipaws.h) at line 172, is serialized as XML schema type *`xsd:language`* and has underlying base type `std::string`, which should be

- matching regex pattern "([a-zA-Z]{2}|[iI]-[a-zA-Z]+|[xX]-[a-zA-Z]{1,8})(-[a-zA-Z]{1,8})*"

[![][1] To top](#)


## Summary of Serializable Types {#doc-types}

Each serializable C/C++ *Type* with binding name *Name* has a set of auto-generated functions:

- `Type *soap_new_Name(struct soap*)` managed allocation and default initialization
- `Type *soap_new_Name(struct soap*, int n)` managed allocation and default initialization of an array `Type[n]`
- `void soap_default_Name(struct soap*, Type*)` initialize or reset non-class *Type* to default)
- `void Type::soap_default(struct soap*)` non-volatile class *Type* reset to default
- `Type *soap_dup_Name(struct soap*, Type *dst, const Type *src)` requires soapcpp2 option -Ec, deep copy `src` to `dst` managed by context or unmanaged when context is NULL, returning `dst` (if `dst` is NULL then allocates `dst` copy)
- `void soap_del_Name(struct soap*, Type*)` requires soapcpp2 option -Ec, deep delete *Type* which must be unmanaged
- `const char *soap_Name2s(struct soap*, Type)` primitive *Type* only, returns string-converted *Type* in temporary string buffer
- `int soap_s2Name(struct soap*, const char*, Type*)` primitive *Type* only, convert string to value, returns `SOAP_OK` or error code
- `int soap_write_Name(struct soap*, const Type*)` serialize *Type* to XML, returns `SOAP_OK` or error code
- `int soap_PUT_Name(struct soap*, const char *URL, const Type*)` REST PUT *Type* in XML, returns `SOAP_OK` or error code
- `int soap_PATCH_Name(struct soap*, const char *URL, const Type*)` REST PATCH *Type* in XML, returns `SOAP_OK` or error code
- `int soap_POST_send_Name(struct soap*, const char *URL, const Type*)` REST POST send *Type* in XML (MUST be followed by a `soap_POST_recv_OtherName`), returns `SOAP_OK` or error code
- `int soap_read_Name(struct soap*, Type*)` deserialize *Type* from XML, returns `SOAP_OK` or error code
- `int soap_GET_Name(struct soap*, const char *URL, Type*)` REST GET *Type* from XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_Name(struct soap*, Type*)` REST GET *Type* from XML (after a `soap_POST_send_OtherName`), returns `SOAP_OK` or error code
- `(Type *)soap_malloc(struct soap*, sizeof(Type))` raw managed allocation of primitive *Type* (types that are not structs or classes) without initialization
- `const char *soap_strdup(struct soap*, const char*)` managed allocation and duplication of string
- `const wchar_t *soap_wstrdup(struct soap*, const wchar_t*)` managed allocation and duplication of wide string

Each *Type* also has a unique type id `SOAP_TYPE_<Type>` that you can use to serialize `void*` in a struct/class by setting the `int __type` member to this type id. The unique type id is also used to distinguish derived class instances from base class instances by calling their `virtual soap_type()` methods that return this type id.

From the toolkit documentation:

- Set `soap->sendfd = fd` to serialize to an `int fd` file descriptor
- Set `soap->os = &os` to serialize to a `std::ostream os`
- Set `soap->recvfd = fd` to deserialize from an `int fd` file descriptor
- Set `soap->is = &is` to deserialize from a `std::istream`
- All managed allocated data is deleted by `soap_destroy(soap)` followed by `soap_end(soap)` with context `soap`

The table below lists the serializable types by *Type*, binding *Name*, *Kind*, and the XSD data binding type and/or element.  Pointers, arrays, and containers of these types are also serializable:

<table class="doxtable">
<tr><th> C/C++ Type </th><th> Name </th><th> Kind </th><th> XML schema name </th></tr>
<tr><td><code> char </code></td><td><code> byte </code></td><td> char </td><td> xsd:byte </td></tr>
<tr><td><code> int </code></td><td><code> int </code></td><td> int </td><td> xsd:int </td></tr>
<tr><td><code> time_t </code></td><td><code> dateTime </code></td><td> time_t </td><td> xsd:dateTime </td></tr>
<tr><td><code><a href="#_ns5__alert_info_certainty"> enum _ns5__alert_info_certainty </a></code></td><td><code> _ns5__alert_info_certainty </code></td><td> enum </td><td> ns5:alert-info-certainty </td></tr>
<tr><td><code><a href="#_ns5__alert_info_severity"> enum _ns5__alert_info_severity </a></code></td><td><code> _ns5__alert_info_severity </code></td><td> enum </td><td> ns5:alert-info-severity </td></tr>
<tr><td><code><a href="#_ns5__alert_info_urgency"> enum _ns5__alert_info_urgency </a></code></td><td><code> _ns5__alert_info_urgency </code></td><td> enum </td><td> ns5:alert-info-urgency </td></tr>
<tr><td><code><a href="#_ns5__alert_info_responseType"> enum _ns5__alert_info_responseType </a></code></td><td><code> _ns5__alert_info_responseType </code></td><td> enum </td><td> ns5:alert-info-responseType </td></tr>
<tr><td><code><a href="#_ns5__alert_info_category"> enum _ns5__alert_info_category </a></code></td><td><code> _ns5__alert_info_category </code></td><td> enum </td><td> ns5:alert-info-category </td></tr>
<tr><td><code><a href="#_ns5__alert_scope"> enum _ns5__alert_scope </a></code></td><td><code> _ns5__alert_scope </code></td><td> enum </td><td> ns5:alert-scope </td></tr>
<tr><td><code><a href="#_ns5__alert_msgType"> enum _ns5__alert_msgType </a></code></td><td><code> _ns5__alert_msgType </code></td><td> enum </td><td> ns5:alert-msgType </td></tr>
<tr><td><code><a href="#_ns5__alert_status"> enum _ns5__alert_status </a></code></td><td><code> _ns5__alert_status </code></td><td> enum </td><td> ns5:alert-status </td></tr>
<tr><td><code><a href="#_ns5__alert_info_area_geocode"> _ns5__alert_info_area_geocode </a></code></td><td><code> _ns5__alert_info_area_geocode </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns5__alert_info_area"> _ns5__alert_info_area </a></code></td><td><code> _ns5__alert_info_area </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns5__alert_info_resource"> _ns5__alert_info_resource </a></code></td><td><code> _ns5__alert_info_resource </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns5__alert_info_parameter"> _ns5__alert_info_parameter </a></code></td><td><code> _ns5__alert_info_parameter </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns5__alert_info_eventCode"> _ns5__alert_info_eventCode </a></code></td><td><code> _ns5__alert_info_eventCode </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns5__alert_info"> _ns5__alert_info </a></code></td><td><code> _ns5__alert_info </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns2__CAPHeaderTypeDef"> _ns2__CAPHeaderTypeDef </a></code></td><td><code> _ns2__CAPHeaderTypeDef </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns2__messageResponseTypeDef"> _ns2__messageResponseTypeDef </a></code></td><td><code> _ns2__messageResponseTypeDef </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns2__postCAPResponseTypeDef"> _ns2__postCAPResponseTypeDef </a></code></td><td><code> _ns2__postCAPResponseTypeDef </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns2__CAPServiceException"> _ns2__CAPServiceException </a></code></td><td><code> _ns2__CAPServiceException </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns2__postCAPRequestTypeDef"> _ns2__postCAPRequestTypeDef </a></code></td><td><code> _ns2__postCAPRequestTypeDef </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns5__alert"> _ns5__alert </a></code></td><td><code> _ns5__alert </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns4__parameterListItem"> _ns4__parameterListItem </a></code></td><td><code> _ns4__parameterListItem </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#ns4__subParameterListItem"> ns4__subParameterListItem </a></code></td><td><code> ns4__subParameterListItem </code></td><td> class </td><td> ns4:subParameterListItem </td></tr>
<tr><td><code><a href="#ns4__responseParameterList"> ns4__responseParameterList </a></code></td><td><code> ns4__responseParameterList </code></td><td> class </td><td> ns4:responseParameterList </td></tr>
<tr><td><code><a href="#ns3__parameterListItem"> ns3__parameterListItem </a></code></td><td><code> ns3__parameterListItem </code></td><td> class </td><td> ns3:parameterListItem </td></tr>
<tr><td><code><a href="#ns3__requestParameterList"> ns3__requestParameterList </a></code></td><td><code> ns3__requestParameterList </code></td><td> class </td><td> ns3:requestParameterList </td></tr>
<tr><td><code> xsd__language </code></td><td><code> xsd__language </code></td><td> std::string </td><td> xsd:language </td></tr>
<tr><td><code> xsd__integer </code></td><td><code> xsd__integer </code></td><td> std::string </td><td> xsd:integer </td></tr>
<tr><td><code> xsd__decimal </code></td><td><code> xsd__decimal </code></td><td> std::string </td><td> xsd:decimal </td></tr>
<tr><td><code> xsd__anyURI </code></td><td><code> xsd__anyURI </code></td><td> std::string </td><td> xsd:anyURI </td></tr>
<tr><td><code> std::string </code></td><td><code> std__string </code></td><td> std::string </td><td> xsd:string </td></tr>
<tr><td><code><a href="#SOAP_ENV__Fault"> struct SOAP_ENV__Fault </a></code></td><td><code> SOAP_ENV__Fault </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#SOAP_ENV__Reason"> struct SOAP_ENV__Reason </a></code></td><td><code> SOAP_ENV__Reason </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#SOAP_ENV__Code"> struct SOAP_ENV__Code </a></code></td><td><code> SOAP_ENV__Code </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#SOAP_ENV__Detail"> struct SOAP_ENV__Detail </a></code></td><td><code> SOAP_ENV__Detail </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#SOAP_ENV__Header"> struct SOAP_ENV__Header </a></code></td><td><code> SOAP_ENV__Header </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#_QName"> _QName </a></code></td><td><code> _QName </code></td><td> string </td><td> xsd:QName </td></tr>
<tr><td><code><a href="#_XML"> _XML </a></code></td><td><code> _XML </code></td><td> string </td><td> (literal XML string) </td></tr>
<tr><td><code> char * </code></td><td><code> string </code></td><td> string </td><td> xsd:string </td></tr>
<tr><td><code> std::vector<_ns5__alert *>  </code></td><td><code> std__vectorTemplateOfPointerTo_ns5__alert </code></td><td> container </td><td>  </td></tr>
<tr><td><code> std::vector<char *>  </code></td><td><code> std__vectorTemplateOf_XML </code></td><td> container </td><td>  </td></tr>
<tr><td><code> std::vector<_ns5__alert_info>  </code></td><td><code> std__vectorTemplateOf_ns5__alert_info </code></td><td> container </td><td>  </td></tr>
<tr><td><code> std::vector<_ns5__alert_info_area>  </code></td><td><code> std__vectorTemplateOf_ns5__alert_info_area </code></td><td> container </td><td>  </td></tr>
<tr><td><code> std::vector<_ns5__alert_info_area_geocode>  </code></td><td><code> std__vectorTemplateOf_ns5__alert_info_area_geocode </code></td><td> container </td><td>  </td></tr>
<tr><td><code> std::vector<_ns5__alert_info_resource>  </code></td><td><code> std__vectorTemplateOf_ns5__alert_info_resource </code></td><td> container </td><td>  </td></tr>
<tr><td><code> std::vector<_ns5__alert_info_parameter>  </code></td><td><code> std__vectorTemplateOf_ns5__alert_info_parameter </code></td><td> container </td><td>  </td></tr>
<tr><td><code> std::vector<_ns5__alert_info_eventCode>  </code></td><td><code> std__vectorTemplateOf_ns5__alert_info_eventCode </code></td><td> container </td><td>  </td></tr>
<tr><td><code> std::vector<enum _ns5__alert_info_responseType>  </code></td><td><code> std__vectorTemplateOf_ns5__alert_info_responseType </code></td><td> container </td><td> ns5:alert-info-responseType </td></tr>
<tr><td><code> std::vector<enum _ns5__alert_info_category>  </code></td><td><code> std__vectorTemplateOf_ns5__alert_info_category </code></td><td> container </td><td> ns5:alert-info-category </td></tr>
<tr><td><code> std::vector<ns4__subParameterListItem *>  </code></td><td><code> std__vectorTemplateOfPointerTons4__subParameterListItem </code></td><td> container </td><td> ns4:subParameterListItem </td></tr>
<tr><td><code> std::vector<_ns4__parameterListItem *>  </code></td><td><code> std__vectorTemplateOfPointerTo_ns4__parameterListItem </code></td><td> container </td><td>  </td></tr>
<tr><td><code> std::vector<std::string>  </code></td><td><code> std__vectorTemplateOfstd__string </code></td><td> container </td><td> xsd:string </td></tr>
<tr><td><code> std::vector<ns3__parameterListItem *>  </code></td><td><code> std__vectorTemplateOfPointerTons3__parameterListItem </code></td><td> container </td><td> ns3:parameterListItem </td></tr>
</table>

[![][1] To top](#)


## Web Service Class CAPSoapHttpService {#doc-server}

This service class is declared in [soapCAPSoapHttpService.h](soapCAPSoapHttpService.h) and defined in [soapCAPSoapHttpService.cpp](soapCAPSoapHttpService.cpp):

    class SOAP_CMAC CAPSoapHttpService {
      public:
        /// Context to manage service IO and data
        struct soap *soap;
        /// flag indicating that this context is owned by this service and should be deleted by the destructor
        bool soap_own;
        /// Variables globally declared in ipaws.h, if any
        /// Construct a service with new managing context
        CAPSoapHttpService();
        /// Copy constructor
        CAPSoapHttpService(const CAPSoapHttpService&);
        /// Construct service given a shared managing context
        CAPSoapHttpService(struct soap*);
        /// Constructor taking input+output mode flags for the new managing context
        CAPSoapHttpService(soap_mode iomode);
        /// Constructor taking input and output mode flags for the new managing context
        CAPSoapHttpService(soap_mode imode, soap_mode omode);
        /// Destructor deletes deserialized data and its managing context, when the context was allocated by the contructor
        virtual ~CAPSoapHttpService();
        /// Delete all deserialized data (with soap_destroy() and soap_end())
        virtual void destroy();
        /// Delete all deserialized data and reset to defaults
        virtual void reset();
        /// Initializer used by constructors
        virtual void CAPSoapHttpService_init(soap_mode imode, soap_mode omode);
        /// Return a copy that has a new managing context with the same engine state
        virtual CAPSoapHttpService *copy() SOAP_PURE_VIRTUAL_COPY;
        /// Copy assignment
        CAPSoapHttpService& operator=(const CAPSoapHttpService&);
        /// Close connection (normally automatic)
        virtual int soap_close_socket();
        /// Force close connection (can kill a thread blocked on IO)
        virtual int soap_force_close_socket();
        /// Return sender-related fault to sender
        virtual int soap_senderfault(const char *string, const char *detailXML);
        /// Return sender-related fault with SOAP 1.2 subcode to sender
        virtual int soap_senderfault(const char *subcodeQName, const char *string, const char *detailXML);
        /// Return receiver-related fault to sender
        virtual int soap_receiverfault(const char *string, const char *detailXML);
        /// Return receiver-related fault with SOAP 1.2 subcode to sender
        virtual int soap_receiverfault(const char *subcodeQName, const char *string, const char *detailXML);
        /// Print fault
        virtual void soap_print_fault(FILE*);
    #ifndef WITH_LEAN
    #ifndef WITH_COMPAT
        /// Print fault to stream
        virtual void soap_stream_fault(std::ostream&);
    #endif
        /// Write fault to buffer
        virtual char *soap_sprint_fault(char *buf, size_t len);
    #endif
        /// Disables and removes SOAP Header from message by setting soap->header = NULL
        virtual void soap_noheader();
        /// Add SOAP Header to message
        virtual void soap_header(_ns2__CAPHeaderTypeDef *ns2__CAPHeaderTypeDef);
        /// Get SOAP Header structure (i.e. soap->header, which is NULL when absent)
        virtual ::SOAP_ENV__Header *soap_header();
    #ifndef WITH_NOIO
        /// Run simple single-thread (iterative, non-SSL) service on port until a connection error occurs (returns SOAP_OK or error code), use this->bind_flag = SO_REUSEADDR to rebind for immediate rerun
        virtual int run(int port, int backlog = 1);
    #if defined(WITH_OPENSSL) || defined(WITH_GNUTLS)
        /// Run simple single-thread SSL service on port until a connection error occurs (returns SOAP_OK or error code), use this->bind_flag = SO_REUSEADDR to rebind for immediate rerun
        virtual int ssl_run(int port, int backlog = 1);
    #endif
        /// Bind service to port (returns master socket or SOAP_INVALID_SOCKET upon error)
        virtual SOAP_SOCKET bind(const char *host, int port, int backlog);
        /// Accept next request (returns socket or SOAP_INVALID_SOCKET upon error)
        virtual SOAP_SOCKET accept();
    #if defined(WITH_OPENSSL) || defined(WITH_GNUTLS)
        /// When SSL is used, after accept() should perform and accept SSL handshake
        virtual int ssl_accept();
    #endif
    #endif
        /// After accept() serve the pending request (returns SOAP_OK or error code)
        virtual int serve();
        /// Used by serve() to dispatch a pending request (returns SOAP_OK or error code)
        virtual int dispatch();
        virtual int dispatch(struct soap *soap);
        //
        // Service operations are listed below: you should define these
        // Note: compile with -DWITH_PURE_VIRTUAL to declare pure virtual methods
        //
        /// Web service operation 'getRequest' implementation, should return SOAP_OK or error code
        virtual int getRequest(ns3__requestParameterList *ns2__getRequestTypeDef, ns4__responseParameterList &ns2__getResponseTypeDef) SOAP_PURE_VIRTUAL;
        //
        /// Web service operation 'postCAP' implementation, should return SOAP_OK or error code
        virtual int postCAP(_ns2__postCAPRequestTypeDef *ns2__postCAPRequestTypeDef, _ns2__postCAPResponseTypeDef &ns2__postCAPResponseTypeDef) SOAP_PURE_VIRTUAL;
        //
        /// Web service operation 'getMessage' implementation, should return SOAP_OK or error code
        virtual int getMessage(ns3__requestParameterList *ns2__getMessageTypeDef, _ns2__messageResponseTypeDef &ns2__messageResponseTypeDef) SOAP_PURE_VIRTUAL;
    };

Use the service request dispatcher to accept and process service requests:

- `int serve()` serves requests by calling one of the service methods that matches the request.  Returns `SOAP_OK` or an error code.  This function supports CGI by accepting a request on stdin and sending the response to stdout, and FastCGI.  To serve over HTTP(S), use the following functions to establish a connection:

- `SOAP_SOCKET bind(const char *host, int port, int backlog)` returns master socket bound to port (and restricted to host name, if not NULL) or `SOAP_INVALID_SOCKET` upon error
- `SOAP_SOCKET accept()` accepts connection and returns socket when accepted, or `SOAP_INVALID_SOCKET` upon error
- `int soap_ssl_accept()` performs SSL handshake and returns `SOAP_OK` when successful or an error code, invoke this method after `accept()` to accept SSL/TLS connection

### Service Operation `CAPSoapHttpService::getRequest()`

This service operation is declared in [ipaws.h](ipaws.h) at line 1073 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action "http://gov.fema.ipaws.services/IPAWS_CAPService/getRequest"
- SOAP response action "http://gov.fema.ipaws.services/IPAWS_CAPService/getRequestResponse"
- Default service endpoint URL "http://vvsoua7.fematdl.net:8210/IPAWS_CAPService/IPAWS"
- Operation namespace prefix `ns2` and URI "[http://gov.fema.ipaws.services/IPAWS_CAPService/](#doc-namespaces)"

The following service class method must be implemented in the service back-end code and will be called by the service dispatcher `CAPSoapHttpService::serve(soap)`:

        //
        /// Web service operation 'getRequest' implementation, should return SOAP_OK or error code
        virtual int getRequest(ns3__requestParameterList *ns2__getRequestTypeDef, ns4__responseParameterList &ns2__getResponseTypeDef) SOAP_PURE_VIRTUAL;

where:

- `ns3__requestParameterList *ns2__getRequestTypeDef` is optional, where the type of this parameter is a pointer to <code><a href="#ns3__requestParameterList"> ns3__requestParameterList </a></code>
- `ns4__responseParameterList &ns2__getResponseTypeDef` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#ns4__responseParameterList"> ns4__responseParameterList </a></code>

This service method should be implemented as part of the service back-end code and return `SOAP_OK` and set the last parameter `ns2__getResponseTypeDef` to the result, or return an error code

[![][1] To top](#)


### Service Operation `CAPSoapHttpService::postCAP()`

This service operation is declared in [ipaws.h](ipaws.h) at line 1150 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action "http://gov.fema.ipaws.services/IPAWS_CAPService/postCAP"
- SOAP response action "http://gov.fema.ipaws.services/IPAWS_CAPService/postCAPResponse"
- Default service endpoint URL "http://vvsoua7.fematdl.net:8210/IPAWS_CAPService/IPAWS"
- Operation namespace prefix `ns2` and URI "[http://gov.fema.ipaws.services/IPAWS_CAPService/](#doc-namespaces)"

The following service class method must be implemented in the service back-end code and will be called by the service dispatcher `CAPSoapHttpService::serve(soap)`:

        //
        /// Web service operation 'postCAP' implementation, should return SOAP_OK or error code
        virtual int postCAP(_ns2__postCAPRequestTypeDef *ns2__postCAPRequestTypeDef, _ns2__postCAPResponseTypeDef &ns2__postCAPResponseTypeDef) SOAP_PURE_VIRTUAL;

where:

- `_ns2__postCAPRequestTypeDef *ns2__postCAPRequestTypeDef` is optional, where the type of this parameter is a pointer to <code><a href="#_ns2__postCAPRequestTypeDef"> _ns2__postCAPRequestTypeDef </a></code>
- `_ns2__postCAPResponseTypeDef &ns2__postCAPResponseTypeDef` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#_ns2__postCAPResponseTypeDef"> _ns2__postCAPResponseTypeDef </a></code>

This service method should be implemented as part of the service back-end code and return `SOAP_OK` and set the last parameter `ns2__postCAPResponseTypeDef` to the result, or return an error code

[![][1] To top](#)


### Service Operation `CAPSoapHttpService::getMessage()`

This service operation is declared in [ipaws.h](ipaws.h) at line 1227 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action "http://gov.fema.ipaws.services/IPAWS_CAPService/getMessage"
- SOAP response action "http://gov.fema.ipaws.services/IPAWS_CAPService/getMessageResponse"
- Default service endpoint URL "http://vvsoua7.fematdl.net:8210/IPAWS_CAPService/IPAWS"
- Operation namespace prefix `ns2` and URI "[http://gov.fema.ipaws.services/IPAWS_CAPService/](#doc-namespaces)"

The following service class method must be implemented in the service back-end code and will be called by the service dispatcher `CAPSoapHttpService::serve(soap)`:

        //
        /// Web service operation 'getMessage' implementation, should return SOAP_OK or error code
        virtual int getMessage(ns3__requestParameterList *ns2__getMessageTypeDef, _ns2__messageResponseTypeDef &ns2__messageResponseTypeDef) SOAP_PURE_VIRTUAL;

where:

- `ns3__requestParameterList *ns2__getMessageTypeDef` is optional, where the type of this parameter is a pointer to <code><a href="#ns3__requestParameterList"> ns3__requestParameterList </a></code>
- `_ns2__messageResponseTypeDef &ns2__messageResponseTypeDef` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#_ns2__messageResponseTypeDef"> _ns2__messageResponseTypeDef </a></code>

This service method should be implemented as part of the service back-end code and return `SOAP_OK` and set the last parameter `ns2__messageResponseTypeDef` to the result, or return an error code

[![][1] To top](#)


## Schemas and Namespaces {#doc-namespaces}

The following schemas and namespaces are used in addition to the predefined SOAP and built-in XSD namespaces:

- Prefix `ns3` is bound to namespace URI *`http://gov.fema.ipaws.services/caprequest`* with local element form default *`qualified`* and attribute form default *`unqualified`*
- Prefix `ns4` is bound to namespace URI *`http://gov.fema.ipaws.services/capresponse`* with local element form default *`qualified`* and attribute form default *`unqualified`*
- Prefix `ns5` is bound to namespace URI *`urn:oasis:names:tc:emergency:cap:1.2`* with local element form default *`qualified`* and attribute form default *`unqualified`*
- Prefix `ns2` is bound to namespace URI *`http://gov.fema.ipaws.services/IPAWS_CAPService/`* with local element form default *`qualified`* and attribute form default *`unqualified`*


The following namespace table is saved to CAPSoapHttp.nsmap:

    struct Namespace namespaces[] = {
        { "SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/", "http://www.w3.org/*/soap-envelope", NULL },
        { "SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/", "http://www.w3.org/*/soap-encoding", NULL },
        { "xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance", NULL },
        { "xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema", NULL },
        { "ns3", "http://gov.fema.ipaws.services/caprequest", NULL, NULL },
        { "ns4", "http://gov.fema.ipaws.services/capresponse", NULL, NULL },
        { "ns5", "urn:oasis:names:tc:emergency:cap:1.2", NULL, NULL },
        { "ns2", "http://gov.fema.ipaws.services/IPAWS_CAPService/", NULL, NULL },
        { NULL, NULL, NULL, NULL}
    };

The table binds XML namespace prefixes (first column) to namespace URIs (second column), similar to xmlns:prefix="URI" in XML.  The third column is a URI pattern with `*` wildcards that is also accepted as a valid namespace URI for inbound XML messages.  The fourth column is NULL.  This table is globally defined for the gSOAP engine.  The engine context will look for it unless you compiled the gSOAP source codes with `-DWITH_NONAMESPACES`.  You must assign this or another namespace table with `soap_set_namespaces(struct soap *soap, struct Namespace *namespaces)` after initializing the context and before processing XML.

[![][1] To top](#)



  [1]: https://www.genivia.com/images/go-up.png

--------------------------------------------------------------------------------

_Generated on Thu Feb 28 2019 01:21:03 UTC by soapcpp2 v2.8.75 for ipaws.h._
_The gSOAP XML Web services tools are Copyright (C) Robert van Engelen, Genivia Inc. All Rights Reserved._
